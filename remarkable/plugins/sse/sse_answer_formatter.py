# ruff: noqa
import hashlib
import json
import logging
import re
from collections import OrderedDict, defaultdict, namedtuple
from copy import deepcopy
from decimal import ROUND_HALF_UP, Decimal
from difflib import SequenceMatcher
from functools import partial

from remarkable.answer.node import AnswerItem
from remarkable.answer.reader import load_scriber_answer
from remarkable.common.image_util import outline_base64_str
from remarkable.common.storage import localstorage
from remarkable.common.util import (
    box_to_outline,
    clean_txt,
    get_num_from_chars,
    group_cells,
    index_in_space_string,
)
from remarkable.pdfinsight.reader import PdfinsightReader
from remarkable.predictor.predict import CharResult, LabelResult, ResultOfPredictor

UNITS = ("<金额单位>", "<数量单位>", "<百分比单位>", "<每股收益单位>")

CURRENCY_PATTERN = re.compile(r"(?P<target>人民币|[港欧美日韩]元)")
DATE_PATTERN = r"(\d+)年度?(\d+月份?)?(\d+日)?"
date_attr_reg = re.compile(r"任期|年度?|日期|时间|(公告|申请|登记|获奖|成立)日|建设期")
AMOUNT_UNIT_PATTERN = r"(^|(?<=[/一二三四五六七八九十\d\s】\]]))(?P<target>([万亿]+)?[港欧美日韩]?[元股倍](/\w)?)"
money_pattern = re.compile(r"(?P<target>[-\d\s.,十百千万亿]+元?(人民币|[欧美日韩港]元)?)")

balance_sheet_attrs = [
    "国内票证结算",
    "长期应收款",
    "期货保证金存款",
    "应收分保未到期责任准备金",
    "未分配利润",
    "其他非流动资产",
    "已结算尚未完工款",
    "应收内部往来",
    "非流动衍生金融负债",
    "应付赔付款",
    "合同负债",
    "交易席位费",
    "吸收存款",
    "库存股",
    "应付票据及应付账款",
    "长期健康险责任准备金",
    "碳排放权",
    "负债和所有者权益总计",
    "预付款项",
    "应付款项",
    "持有至到期投资减值准备",
    "其他非流动负债",
    "盈余公积",
    "民营资本",
    "所有者权益合计",
    "实收资本净额",
    "应付分保账款",
    "其他资产",
    "寿险责任准备金",
    "生产性生物资产累计折旧",
    "投资性房地产累计摊销",
    "货币资金",
    "应付保费",
    "一年内到期的流动资产",
    "应收分保未决赔款准备金",
    "卖出回购金融资产款",
    "向中央银行借款",
    "受托代销商品",
    "企业发展基金",
    "专项应付款",
    "应收保费",
    "其他应交款",
    "坏账准备的转回",
    "生产性生物资产净值",
    "应收佣金及手续费",
    "买入返售金融资产",
    "融资租赁资产",
    "一般风险准备",
    "负债：",
    "短期保理借款",
    "吸收存款及同业存放",
    "资本公积",
    "累计折旧",
    "利润归还投资",
    "保险保障基金",
    "拆出资金",
    "消耗性生物资产",
    "未到期责任准备金",
    "一年内到期的非流动负债",
    "特准储备物资",
    "其他权益工具投资",
    "应收分保寿险责任准备金",
    "应付次级债券",
    "存入保证金",
    "应交税费",
    "递延所得税资产",
    "应收账款及合同资产",
    "工程物资",
    "以公允价值计量且其变动计入当期损益的金融资产",
    "母公司拨款",
    "现金股利",
    "损余物资",
    "少数股东权益",
    "应收保理款",
    "债权计划投资",
    "短期可供出售金融资产",
    "风险准备金",
    "应付股利",
    "应付佣金",
    "应收账款坏账准备",
    "代理业务负债",
    "应收出口退税款",
    "应付质押保证金",
    "交易性金融资产",
    "预计负债",
    "发放贷款及垫款—短期",
    "使用权资产",
    "应收担保费",
    "非流动负债合计",
    "存货净额",
    "金融投资",
    "应付保单红利",
    "贵金属",
    "固定资产",
    "固定资产清理",
    "预收保费",
    "无形资产",
    "应收代偿款",
    "非流动负债：",
    "非流动资产：",
    "预付赔款",
    "投资性房地产减值准备",
    "保户质押贷款",
    "融出资金",
    "客户备付金",
    "代理承销证券款",
    "以公允价值计量且其变动计入当期损益的金融负债",
    "独立账户负债",
    "应收股利",
    "保费准备金",
    "存货跌价准备",
    "应付期货投资者保障基金",
    "信托赔偿准备金",
    "短期应付债券",
    "递延所得税负债",
    "流动资产：",
    "固定资产原价",
    "投资性房地产",
    "未决赔款准备金",
    "应收款项类投资",
    "应付短期债券",
    "工程及工程物资预付款",
    "代付赔款",
    "代理业务资产",
    "负债合计",
    "拨付所属资金",
    "长期借款",
    "预付手续费",
    "其他应付款中的其他应付款",
    "应收证券清算款",
    "交易性金融负债",
    "资产总计",
    "应付手续费及佣金",
    "投资性艺术品",
    "应付债券中的永续债",
    "个人资本",
    "预收款项",
    "发放贷款及垫款",
    "流动负债合计",
    "应收风险损失款",
    "其他权益工具",
    "剧目创编",
    "非流动资产合计",
    "银行存款",
    "应收款项",
    "长期预付款项",
    "一年内到期的非流动资产",
    "期货会员资格",
    "固定资产净值",
    "国际票证结算",
    "向其他金融机构借款",
    "非流动衍生金融资产",
    "生产性生物资产",
    "合同资产",
    "客户存款",
    "存入分保准备金",
    "其他应付款",
    "应付工资",
    "原材料",
    "代理买卖证券款",
    "信用交易代理买卖证券款",
    "已完工尚未结算款",
    "长期股权投资减值准备",
    "应收分保账款",
    "以摊余成本计量的金融资产",
    "独立账户资产",
    "应付利息",
    "应付债券",
    "特准储备基金",
    "产成品",
    "应收账款",
    "应收手续费及佣金",
    "交易风险准备",
    "大灾风险利润准备金",
    "其他流动负债",
    "递延收益",
    "开发产品",
    "融入资金",
    "保险合同准备金",
    "应收账款类投资",
    "应收补贴款",
    "其他应收款坏账准备",
    "勘探成本",
    "应付短期融资款",
    "投资性房地产净值",
    "流动负债：",
    "其他应收款净额",
    "生产性生物资产原值",
    "应付内部往来",
    "持有待售非流动资产",
    "租赁负债",
    "其他流动资产",
    "长期待摊费用",
    "横表名称",
    "法定盈余公积",
    "应付债券中的优先股",
    "土地使用权",
    "应收票据及应收账款",
    "短期借款",
    "现金及存放中央银行款项",
    "在建工程",
    "委托贷款",
    "生产性生物资产减值准备",
    "任意公积金",
    "代理客户结算款",
    "归入贷款及应收款的投资",
    "资产：",
    "预提费用",
    "库存商品",
    "持有待售资产",
    "流动资产合计",
    "在建工程减值准备",
    "应收票据",
    "短期贷款",
    "长期应付款",
    "应收佣金",
    "其他非流动金融资产",
    "应付福利费",
    "其他权益工具中的永续债",
    "持有待售负债",
    "存货",
    "一年内到期的预计负债",
    "租赁保证金",
    "外币报表折算差额",
    "期货风险准备金",
    "抵债资产",
    "固定资产合计",
    "预收账款及合同负债",
    "应收货币保证金",
    "所有者权益：",
    "应付货币保证金",
    "债权投资",
    "其他债权投资",
    "其他应收款中的其他应收款",
    "库存商品及产成品",
    "担保业务准备金",
    "股本",
    "其他负债",
    "应收质押保证金",
    "国有法人资本",
    "长期股权投资",
    "担保赔偿准备金",
    "应收分保合同保证金",
    "衍生金融负债",
    "应交税金",
    "已发行存款证",
    "其他综合收益",
    "存放同业款项",
    "在建工程净额",
    "衍生金融资产",
    "应付融资租赁款",
    "公允价值变动",
    "专项储备",
    "结算备付金",
    "存出保证金",
    "储备基金",
    "应收分保长期健康险责任准备金",
    "保户储金及投资款",
    "开发支出",
    "其他应收款",
    "应收结算担保金",
    "应付账款",
    "长期应付职工薪酬",
    "短期投资",
    "文化资产",
    "预付账款",
    "固定资产减值准备",
    "应付票据",
    "定期存款",
    "应付证券清算款",
    "应付职工薪酬",
    "应收融资租赁款",
    "已发生未报告未决赔款准备金",
    "商誉",
    "发放贷款及垫款中的贷款",
    "应收分保合同准备金",
    "国有资本",
    "归属于母公司普通股股东权益合计",
    "长期股权投资净额",
    "持有至到期投资",
    "油气资产",
    "存放中央银行款项",
    "应收利息",
    "应收账款净额",
    "应收代位追偿款",
    "可供出售金融资产",
    "其他权益工具中的优先股",
    "拆入资金",
    "公益性生物资产",
]
income_sheet_attrs = [
    "增信业务收入",
    "主营业务成本",
    "信用管理收入",
    "业务及管理费",
    "其他业务支出",
    "营业成本",
    "其他资产减值损失",
    "净敞口套期损益",
    "母公司外币财务报表折算差额",
    "扣除非经常性损益后归属于公司普通股股东的净利润",
    "加权平均净资产收益率",
    "评级服务收入",
    "对联营企业和合营企业投资收益",
    "持有至到期投资重分类为可供出售金融资产损益",
    "借款利息收入",
    "财务费用",
    "其他流动资产公允价值变动损益",
    "管理咨询费净收入",
    "税金及附加",
    "非流动资产处置收益",
    "权益法下在被投资单位以后将重分类进损益的其他综合收益中享有的份额",
    "按经营持续性分类：",
    "金融资产重分类计入其他综合收益的金额",
    "持续经营净利润",
    "同一控制下企业合并被合并方合并前少数股东损益",
    "其他权益工具投资公允价值变动",
    "非货币性资产交换利得",
    "已赚保费收入",
    "保险业务手续费及佣金支出",
    "营业总成本",
    "投资收益",
    "按所有权归属分类：",
    "处置可供出售金融资产其他综合收益转出的份额",
    "可供出售的证券",
    "非流动资产处置损失",
    "受托资产管理收入",
    "托管费",
    "研发费用",
    "权益法下在被投资单位不能重分类进损益的其他综合收益中享有的份额",
    "政府补助",
    "提取保险合同准备金净额",
    "归属于母公司其他权益工具持有者的综合收益总额",
    "委托贷款收入",
    "提取风险准备金",
    "金融业务投资收益",
    "归属于母公司所有者的净利润",
    "佣金支出",
    "出售零碎股所得",
    "综合收益总额",
    "提取未到期责任准备金",
    "采用公允价值计量的投资性房地产处置时转出原计入其他综合收益的金额",
    "利息支出",
    "手续费及佣金净支出",
    "其他代理业务收入",
    "稀释每股收益",
    "所得税费用",
    "非保险业务手续费及佣金净收入",
    "被合并方在合并前实现的净利润",
    "归属于母公司股东及其他权益持有者的净利润",
    "公允价值变动收益",
    "管理费用",
    "归属于少数股东的其他综合收益的税后净额",
    "投资管理业务成本",
    "基金管理费收入",
    "利息净收入",
    "手续费及佣金支出",
    "少数股东损益",
    "利息收入",
    "非流动资产处置利得",
    "非货币性资产交换收益",
    "非投资性房地产转换为采用公允价值计量的投资性房地产时（转换日）公允价值大于账面价值的差额",
    "产品销售收入",
    "投资咨询业务收入",
    "赔付支出",
    "佣金净收入",
    "利息费用",
    "销售费用",
    "归属于母公司所有者的其他综合收益的税后净额",
    "以后将重分类进损益的其他综合收益",
    "资产处置收益",
    "汇兑净损失",
    "数据服务收入",
    "资产管理业务手续费净收入",
    "重新计量设定受益计划净负债或净资产的变动",
    "每股收益：",
    "保险合同赔付支出净额",
    "摊回赔付支出",
    "投资管理业务收入",
    "持有待售处置组处置收益",
    "归属于母公司其他权益工具持有者的净利润",
    "资产处置损失",
    "其他综合收益的税后净额",
    "归属于少数股东的综合收益总额",
    "可供出售金融资产产生的收益",
    "对联营企业和合营企业的投资收益",
    "营业收入中其他业务收入",
    "主营业务收入",
    "其他手续费及佣金收入",
    "营业收入",
    "利润总额",
    "其他业务收入",
    "房屋经营收入",
    "以摊余成本计量的金融资产终止确认产生的收益",
    "摊回退保金支出",
    "子公司外币财务报表折算差额",
    "提取担保赔偿准备、未到期责任准备",
    "保单红利支出",
    "手续费及佣金收入",
    "净利润",
    "持有待售子公司利润总额",
    "其他以后将重分类进损益的其他综合收益",
    "其他债权投资公允价值变动",
    "担保赔偿支出",
    "分保费用",
    "分出保费",
    "经纪业务手续费净收入",
    "代理收入",
    "其他债权投资信用减值准备",
    "债务重组利得",
    "分出担保费",
    "贷款减值损失",
    "担保支出",
    "投资银行业务手续费净收入",
    "非货币性资产交换损失",
    "分保费收入",
    "同一控制下企业合并被合并方合并前归属于母公司的净利润",
    "外币财务报表折算差额",
    "自有资产管理收入",
    "退保金",
    "担保业务收入",
    "除同一控制下企业合并被合并方合并前净利润外的归属于母公司股东的净利润",
    "典当综合费收入",
    "风险管理业务收入",
    "企业自身信用风险公允价值变动",
    "小额信贷收入",
    "债务重组中因处置非流动资产收益",
    "基本每股收益",
    "产品销售成本",
    "提取保险责任准备金",
    "年度损益调整",
    "现金流量套期损益的有效部分",
    "提取担保赔偿准备金",
    "可供出售金融资产变动损益",
    "利息及综合费净收入",
    "一揽子交易处置对子公司股权投资在丧失控制权之前产生的投资收益",
    "保险业务收入",
    "债务重组损失",
    "营业外支出",
    "手续费收入",
    "应占联营及合营公司的其他综合收益",
    "以公允价值计量且其变动计入其他综合收益的金融资产公允价值变动损益",
    "以后不能重分类进损益的其他综合收益",
    "固定资产处置收益",
    "信用减值损失",
    "处置被投资单位其他综合收益转出的份额",
    "终止经营净利润",
    "监管费收入",
    "营业总收入",
    "融资租赁收入",
    "汇兑收益",
    "营业外收入",
    "其他以后不能重分类进损益的其他综合收益",
    "除同一控制下企业合并被合并方合并前少数股东损益外的少数股东损益",
    "提取期货风险准备金",
    "归属于母公司所有者的综合收益总额",
    "资产减值损失",
    "代理销售金融产品收入",
    "咨询费收入",
    "其他收益",
    "营业利润",
    "摊回分保费用",
    "勘探费用",
    "横表名称",
    "赔付支出净额",
    "手续费及佣金净收入",
    "其他业务利润",
    "摊回保险责任准备金",
]
cashflow_sheet_attrs = [
    "收回借款及垫款收到的现金",
    "金融资产和投资净增加额",
    "客户贷款及垫款净增加额",
    "回购库存股",
    "向合营公司提供委托贷款",
    "购置其他债权投资及其他权益工具投资净减少额",
    "投资子公司收到的现金",
    "期初现金及现金等价物余额",
    "收取利息的现金",
    "投资可供出售净增加额",
    "以公允价值计量且其变动计入当期损益的金融工具支付的现金净额",
    "取得投资收益收到的现金",
    "存入保证金收到的现金",
    "衍生金融资产支付的现金净额",
    "限制性银行存款增加",
    "向银行借款收到的现金",
    "收回委托贷款收到的现金",
    "收到与资产相关的政府补助",
    "向中央银行借款净增加额",
    "收回客户贷款及垫款的现金",
    "购买及处置以公允价值计量且其变动计入当期损益的金融资产支付的现金净额",
    "购置以公允价值计量且其变动计入当期损益的金融资产及可供出售金融资产净减少额",
    "支付与投资管理业务有关的现金",
    "与满足资本化条件开发支出直接相关项目所支付的现金",
    "投资活动现金流入小计",
    "证券投资的现金变动净额",
    "购买上海新昇收到的现金净额",
    "吸收存款和同业及其他金融机构存放款项净增加额",
    "存放中央银行净增加额",
    "收到子公司归还暂借款",
    "向中央银行借款净减少额",
    "回购限制性股票",
    "收到其他与经营活动有关的现金",
    "收到担保业务担保费取得的现金",
    "其他权益工具派息支付的现金",
    "代理承销证券支付的现金净额",
    "划分至持有待售的货币资金",
    "发行债券收到的现金",
    "卖出回购金融资产净减少额",
    "收回子公司借款收到的现金",
    "购建固定资产、无形资产和其他长期资产支付的现金",
    "购买以公允价值计量且其变动计入当期损益的金融资产支付的现金",
    "发放委托贷款支付的现金",
    "经营活动产生的现金流量：",
    "应收保理款净增加额",
    "金融业务发放贷款的净减少额",
    "归还存入保证金支付的现金",
    "收购子公司获得的现金",
    "购买上海新昇支付的现金净额",
    "代理买卖证券收到的现金净额",
    "购买及处置以公允价值计量且其变动计入当期损益的金融资产收到的现金净额",
    "卖出回购资金净减少额",
    "取得受限资金的增加",
    "收购少数股东股权所支付的现金",
    "收到票据贴现的现金",
    "支付利息、手续费及佣金的现金",
    "以现金支付的业务及管理费",
    "买卖衍生金融工具支付的现金净额",
    "买入返售投资支付的现金",
    "收回买入返售收到的现金",
    "借款及同业拆借净增加额",
    "应收款项类投资净减少额",
    "客户存款和同业存放款项净减少额",
    "应收款项类投资净增加额",
    "存放中央银行款项净减少额",
    "收到子公司上缴资金",
    "汇率变动对现金及现金等价物的影响",
    "支付客户贷款及垫款",
    "使用受限资金的增加",
    "收到其他与筹资活动有关的现金",
    "保户储金及投资款净减少额",
    "购入以公允价值计量且其变动计入当期损益的金融资产净增加额",
    "购买Okmetic支付的现金净额",
    "销售商品、提供劳务收到的现金",
    "减少股本所支付的现金",
    "收回关联方贷款收到的现金",
    "吸收存款及同业存款净减少额",
    "购买Soitec支付的现金净额",
    "代理买卖证券支付的现金净额",
    "购买子公司和其他经营单位支付的现金",
    "保户储金及投资款净增加额",
    "支付再保险业务现金净额",
    "子公司减资支付给少数股东的现金",
    "代理承销证券收到的现金净额",
    "收到其他与投资管理活动有关的现金",
    "支付的各项税费",
    "定期存款到期收到的现金",
    "代理买卖证券款净减少额",
    "发放贷款净减少额",
    "存放同业及其他金融机构款项净增加额",
    "发放贷款及垫款的净减少额",
    "吸收存款及同业存放净减少额",
    "特许经营权项目投资支付的现金",
    "支付原担保合同赔付款项的现金",
    "拆出资金净减少额",
    "收回少数股东借款收到的现金",
    "收回合营公司委托贷款收到的现金",
    "支付限制性股票回购款",
    "代理兑付债券收到的现金净额",
    "收到的租赁收益",
    "筹资活动产生的现金流量：",
    "购置以公允价值计量且变动计入当期损益的金融资产及可供出售金融资产净减少额",
    "使用受限资金的减少",
    "金融业务收到的贷款利息",
    "偿还短期融资券支付的现金",
    "投资活动现金流出小计",
    "收回其他投资收到的现金",
    "处置可供出售金融资产净减少额",
    "金融业务发放贷款的净增加额",
    "支付的Wind投资款",
    "支付其他与筹资活动有关的现金",
    "以公允价值计量且其变动计入当期损益的金融负债净减少额",
    "向第三方贷款支付的现金",
    "代理兑付债券支付的现金净额",
    "存放中央银行和同业款项净减少额",
    "支付子公司往来暂借款",
    "偿还其他公司借款支付现金",
    "子公司支付给少数股东的股利、利润",
    "处置固定资产、无形资产和其他长期资产收回的现金净额",
    "处置以公允价值计量且其变动计入当期损益的金融负债现金净增加额",
    "偿付卖出回购投资支付的现金",
    "分配利润支付的现金",
    "持有、处置金融资产和投资取得的收益",
    "以公允价值计量且其变动计入当期损益的金融资产净减少额",
    "收到的税收返还",
    "筹资活动现金流出小计",
    "支付给职工以及为职工支付的现金",
    "收回投资收到的现金",
    "划分为持有待售资产的现金及现金等价物余额",
    "质押贷款净增加额",
    "买入返售金融资产净增加额",
    "应收款项类投资支付的现金净额",
    "取得借款收到的现金",
    "丧失对子公司控制权所减少的现金",
    "投资活动产生的现金流量净额",
    "经营租赁收入",
    "不含特许经营权项目投资支付的现金的经营活动现金流量净额",
    "处置权益工具投资收到的现金",
    "从关联方及子公司获得借款和资金往来",
    "收取担保费、手续费及佣金所收到的现金",
    "购置权益工具投资支付的现金",
    "新股发行收到的现金",
    "支付保险保障基金",
    "买入以公允价值计量且变动计入当期损益的金融资产净增加额",
    "融资租赁支付的现金",
    "购置金融资产净增加额",
    "回购业务资金减少额",
    "收到的客户融资租赁的款项",
    "金融资产和投资净减少额",
    "不再纳入合并报表时的子公司账面现金",
    "购买商品、接受劳务支付的现金",
    "支付再担保业务赔付款项的现金",
    "归还关联方资金",
    "饲喂生物资产所支付的现金",
    "卖出回购资产净减少额",
    "设立合营公司支付的现金净额",
    "买卖可供出售金融资产收到的现金净额",
    "处置以公允价值计量且其变动计入当期损益的金融资产净收到的现金",
    "投资以公允价值计量且变动计入当期损益的金融资产净增加额",
    "卖出回购资金净增加额",
    "支付结构化主体其他持有人的现金",
    "处置以公允价值计量且其变动计入当期损益的金融资产净增加额",
    "融出资金净减少额",
    "回购业务支付的现金净额",
    "发放贷款及垫款净增加额",
    "定期存款存入的现金",
    "处置子公司收到的预收款",
    "处置子公司及其他营业单位收到的现金净额",
    "收到的政府补助",
    "偿还债务支付的现金",
    "支付NSIGEuropeHoldingS.A.R.L投资款",
    "卖出回购投资收到的现金",
    "筹资活动其他项目",
    "发行永续债收到的现金",
    "收到原保险合同保费取得的现金",
    "支付担保业务赔付款项的现金",
    "投资活动产生的现金流量：",
    "向其他金融机构拆入资金净减少额",
    "收到其他与投资活动有关的现金",
    "存放同业款项净减少额",
    "买入返售业务资金净减少额",
    "筹资活动现金流入小计",
    "收到再保险业务现金净额",
    "回购公司股票所支付的现金",
    "处置金融资产净增加额",
    "购买非上市公司股权",
    "提供担保等业务收到的现金",
    "收回存出保证金收到的现金",
    "发放贷款净增加额",
    "金融业务支付的利息",
    "处置以公允价值计量且其变动计入当期损益的金融资产净减少额",
    "购置交易性金融工具净减少额",
    "取得股东借款收到的现金",
    "购买新傲科技支付的现金净额",
    "现金及现金等价物净增加额",
    "衍生金融资产收到的现金净额",
    "处置生产性生物资产收回的现金",
    "经营活动现金流入小计",
    "收到少数股东投资",
    "取得利息收入收到的现金",
    "买入返售金融资产净减少额",
    "收回的土地定金",
    "发行短期债券及短期收益凭证收到的现金",
    "客户贷款净减少额",
    "客户贷款及垫款的净减少额",
    "投资合营公司支付的现金",
    "非同一控制下企业合并收到的现金",
    "支付其他与投资管理活动有关的现金",
    "存放中央银行和同业款项净增加额",
    "购买可供出售债务工具支付的现金",
    "发行短期融资券收到的现金",
    "增加子公司投资支付的现金",
    "客户贷款及垫款所支付的现金",
    "吸收投资收到的现金",
    "同业拆入、拆出资金净额",
    "客户贷款及垫款所收回的现金",
    "长期债券回售所支付的现金",
    "回购业务资金净增加额",
    "支付保理业务款项净增加额",
    "收到的股息红利",
    "购置以公允价值计量且其变动计入当期损益的金融工具净减少额",
    "向其他金融机构偿还资金净减少额",
    "衍生金融工具投资收益",
    "支付保单红利的现金",
    "信托存款收支净额",
    "收到担保代偿款项现金",
    "发行长期债券及长期收益凭证收到的现金",
    "收到保证金存款",
    "拆入资金净增加额",
    "处置可供出售权益工具收回的现金",
    "分配股利、利润或偿付利息支付的现金",
    "向关联方及子公司偿还借款和资金往来",
    "同业存放净减少额",
    "投资可供出售金融资产净增加额",
    "融资租赁收到的现金",
    "可供出售债务工具到期收到的现金",
    "支付以公允价值计量且其变动计入当期损益的金融负债现金净额",
    "卖出回购金融资产净增加额",
    "客户贷款净增加额",
    "拆出资金净增加额",
    "融出资金净增加额",
    "支付其他与投资活动有关的现金",
    "以公允价值计量且其变动计入当期损益的金融资产净增加额",
    "存出保证金支付的现金",
    "收到与投资管理业务有关的现金",
    "应收款项类投资现金净增加额",
    "吸收客户净减少额",
    "向其他金融机构拆入资金净增加额",
    "客户贷款支付的现金",
    "取得其他借款收到的现金",
    "取得非业务子公司及其他单位支付的现金净额",
    "偿还债券支付的现金",
    "向其他金融机构借入资金的净减少额",
    "子公司的期初现金余额",
    "同一控制下业务合并对现金的影响",
    "应收债权类金融资产出售的现金净额",
    "支付的土地定金",
    "向一致行动人及母公司借款所收到的现金",
    "发行中期票据收到的现金",
    "收到利息、手续费及佣金的现金",
    "筹资活动产生的现金流量净额",
    "归还投资支付的现金",
    "为交易目的而持有的金融资产净减少额",
    "收到的税费返还",
    "购买生物资产所支付的现金",
    "代理客户结算款净增加额",
    "增加使用受限制定期存款所支付的现金",
    "发行股份购买资产收到的现金",
    "购置权益工具支付的现金",
    "子公司发行永续债收到的现金",
    "其他投资支付的现金",
    "吸收存款和同业及其他金融机构存放款项净减少额",
    "支付客户的融资租赁款项",
    "保户质押贷款净减少额",
    "代收保费专户资金",
    "客户存款净增加额",
    "支付的租金",
    "向联营企业增资所支付的现金",
    "收到的基金管理费",
    "处置子公司及其他营业单位支付的现金净额",
    "支付其他与经营活动有关的现金",
    "增加受限制使用货币资金的现金净额",
    "收回保理款项收到的现金",
    "偿还母公司借款支付现金",
    "售后租回融资租赁收到的现金",
    "同一控制下企业合并支付的现金",
    "取得合营企业支付的现金净额",
    "保证金存款减少额",
    "处置长期股权投资收回的现金净额",
    "取得子公司及其他营业单位支付的现金净额",
    "减少受限制使用货币资金的现金净额",
    "子公司吸收少数股东投资收到的现金",
    "向其他公司借款收到现金",
    "经营活动现金流出小计",
    "横表名称",
    "为交易目的而持有的金融资产净增加额",
    "向子公司下拨资金",
    "支付以公允价值计量且其变动计入当期损益的金融资产现金净额",
    "向关联方贷款支付的现金",
    "取得其他股权投资支付的现金",
    "分配股利支付的现金",
    "购买子公司少数股权所支付的现金",
    "期末现金及现金等价物余额",
    "收取手续费及佣金的现金",
    "偿付利息支付的现金",
    "收到再担保业务担保费取得的现金",
    "期末受限资金金额",
    "支付上海硅欧投资款",
    "支付原保险合同赔付款项的现金",
    "客户存款和同业存放款项净增加额",
    "客户存放和同业存放款项净减少额",
    "拆入资金净减少额",
    "购置或处置持有至到期投资现金净减少额",
    "偿还其他权益工具支付的现金",
    "客户借款及垫款净增加额",
    "回购业务资金净减少额",
    "可供出售金融资产出售的现金净额",
    "保证金存款增加额",
    "设立子公司支付的现金净额",
    "关联方及子公司向本公司偿还借款和资金往来",
    "经营活动产生的现金流量净额",
    "保户质押贷款净增加额",
    "投资支付的现金",
    "合并结构化主体的现金净增加额",
]

dst_attrs = {
    "概览-主要会计数据及财务指标": [
        "资产总额",
        "归属于母公司所有者权益",
        "资产负债率（母公司）",
        "资产负债率（合并）",
        "营业收入",
        "净利润",
        "归属于母公司所有者的净利润",
        "扣除非经常性损益后归属于母公司所有者的净利润",
        "基本每股收益",
        "稀释每股收益",
        "加权平均净资产收益率",
        "经营活动产生的现金流量净额",
        "现金分红",
        "研发投入占营业收入的比例",
        "息税折旧摊销前利润",
    ],
    "财务会计信息-主要财务指标": [
        "流动比率",
        "速动比率",
        "资产负债率（合并）",
        "资产负债率（母公司）",
        "应收账款周转率",
        "存货周转率",
        "研发投入占营业收入的比例",
        "归属于发行人股东的每股净资产",
        "息税折旧摊销前利润",
        "归属于发行人股东的净利润",
        "归属于发行人股东扣除非经常性损益后的净利润",
        "每股经营活动产生的现金流量",
        "每股净现金流量",
        "基本每股收益",
        "稀释每股收益",
        "净资产收益率",
        "主营业务收入增长率",
        "无形资产占净资产比例",
        "总资产周转率",
        "利息保障倍数",
    ],
    "IPO资产负债表（合并）": balance_sheet_attrs,
    "IPO资产负债表（母公司）": balance_sheet_attrs,
    "IPO利润表（合并）": income_sheet_attrs,
    "IPO利润表（母公司）": income_sheet_attrs,
    "IPO现金流量表（合并）": cashflow_sheet_attrs,
    "IPO现金流量表（母公司）": cashflow_sheet_attrs,
    "财务会计信息-非经常性损益": [
        "根据税收、会计等法律、法规的要求对当期损益进行一次性调整对当期损益的影响",
        "因不可抗力因素，如遭受自然灾害而计提的各项资产减值准备",
        "可转换公司借款公允价值变动损失",
        "受托经营取得的托管费收入",
        "或有对价支出",
        "非经常性损益净额占净利润比例",
        "扣除非经常性损益后归属于母公司所有者的净利润",
        "持有和处理交易性金融资产取得的投资收益",
        "除上述各项之外的其他营业外收入和支出",
        "计入当期损益的对非金融企业收取的资金占用费",
        "公允价值变动损益",
        "企业重组费用（如安置职工的支出、整合费用等）",
        "采用公允价值模式进行后续计量的投资性房地产公允价值变动产生的损益",
        "交易价格显失公允的交易产生的超过公允价值部分的损益",
        "同一控制下企业合并产生的子公司期初至合并日的当期净损益",
        "分步收购非同一控制下企业合并产生的投资收益",
        "购买日之前原持有股权按照公允价值重新计量所产生的利得",
        "加：归属于少数股东的非经常性净（收益）/损失",
        "一次性股权激励费用股份支付",
        "归属于母公司所有者的净利润",
        "扣除非经常性损益后净利润",
        "质量赔偿收入",
        "少数股东损益影响额",
        "少数股东权益影响额",
        "理财产品收益",
        "债务重组损益",
        "滞纳金",
        "捐赠性收支净额",
        "企业取得子公司、联营企业及合营企业的投资成本小于取得投资时应享有被合并单位可辨认净资产公允价值产生的收益",
        "非流动资产处置损益",
        "计入当期损益的政府补助",
        "非经常性损益净额占归属于母公司所有者净利润的比例",
        "委托他人投资或管理资产的损益",
        "单独进行减值测试的应收款项减值准备转回",
        "越权审批或无正式批准文件的税收返还、减免",
        "其他符合非经常性损益定义的损益项目",
        "与公司正常经营业务无关的或有事项产生的损益",
        "净利润",
        "委托贷款在持有期间取得的收益",
        "其他投资收益",
        "非经常性损益",
        "归属于母公司所有者的税后非经常性损益",
        "支付供应商和客户的违约金",
        "处置长期股权投资损益",
        "结构性存款产生的收益",
        "所得税影响额",
        "非货币性资产交换损益",
        "无需支付的款项",
        "资产减值准备的冲销部分",
        "非经常性损益税后净额",
    ],
}


def clear_financial_attr(attr, clear_paren=True):
    attr = re.sub(r"^([()（）\[\]【】一二三四五六七八九十\d、.]*)?", "", attr)
    attr = re.sub(r"^其中[:：]?", "", attr)
    if clear_paren:  # 清除末尾的括号
        attr = re.sub(r"[(（].*[)）]$", "", attr)
    return attr


def match_financial_attr(attr, dst_list):
    """
    匹配财务属性名称
    :param attr:  带转换的属性
    :param dst_list:  待选列表
    :return:
    """

    _map = {
        "归属母公司所有者的净利润": ["^归属于?母公司(所有者|股东)的?净利润$"],
        "归属于母公司所有者权益": ["^归属于?母公司(所有者|股东)的?权益(合计)?$"],
        "股本": ["^[(（]?股本/|/股本[)）]?$"],
        "所有者权益：": ["^(所有者|股东)权益[:：]?$"],
        "所有者权益合计": ["^(所有者|股东)权益[总合]计$"],
        "收到的税费返还": ["^收到的税费返还(现金)?$", "^税费返还收到的?现金$"],
        "重新计量设定受益计划净负债或净资产的变动": ["^重新计量设定受益计划变动额$"],
        "权益法下在被投资单位以后将重分类进损益的其他综合收益中享有的份额": ["^权益法下可转损益"],
        "权益法下在被投资单位不能重分类进损益的其他综合收益中享有的份额": ["^权益法下不能转损益"],
        "以后将重分类进损益的其他综合收益": ["^以后[将会能]重分类进损益的其[他它]综合收益"],
        "以后不能重分类进损益的其他综合收益": ["^以后不能重分类进损益的其[他它]综合收益"],
        "负债和所有者权益总计": ["^负债和(所有者|股东)权益[总合]计$"],
        "资产负债率（母公司）": ["^资产负债率.*母公司"],
        "资产负债率（合并）": ["^资产负债率.*合并"],
        "归属于发行人股东的净利润": ["^归属于?母公司(所有者|股东)?的?净利润"],
        "归属于发行人股东扣除非经常性损益后的净利润": [
            "^扣除?非.*?归属于?母公司(所有者|股东)?的?净利润",
            "^归属于?母公司(所有者|股东)?扣除?非.*?的?净利润",
        ],
    }

    scope = {}
    for _ in dst_list:
        scope.setdefault(_, ["^%s$" % _])
        if _ in _map:
            scope[_].extend(_map[_])
    clear_paren = any(x not in attr for x in ("资产负债率",))
    attr = clear_financial_attr(attr, clear_paren=clear_paren)
    # print('match_financial_attr', attr, attr in dst_list)

    for dst, patterns in scope.items():
        if any(re.search(reg, attr) for reg in patterns):
            # print('~~~~~~', attr, dst, patterns)
            return dst
    return None


def guess_attr(attr, dst_list, threshold=0.7):
    def _lookup(word):
        lst = [(_attr, SequenceMatcher(None, word, _attr).ratio()) for _attr in dst_list]
        # print('guess_attr', word, sorted(lst, key=lambda x: x[1])[:5])
        _attr, ratio = sorted(lst, key=lambda x: x[1])[-1]
        if ratio > threshold:
            return _attr
        return None

    attr = clear_financial_attr(attr)
    res = _lookup(attr)
    # 项目名中可能包含多个括号, 拆开再对比一次
    if not res and attr.count("（") > 0:
        res = _lookup(attr.split("（")[0])
    # 母/子公司 -> 发行人
    if not res and re.search(r"[母|子]公司", attr):
        res = _lookup(re.sub(r"[母|子]公司", "发行人", attr))
    # 所有者 -> 股东
    if not res and re.search(r"所有者", attr):
        res = _lookup(re.sub(r"所有者", "股东", attr))
    return res


class MarkException(Exception):
    """可能的标注错误"""


class AssociationType:
    """关联类型"""

    def __init__(self, item):
        self.types = {}
        self.item = deepcopy(item)
        self.split_answer()

    def split_answer(self):
        """将可能有多个单元格标注的关联类型分隔开"""
        if not self.item or not self.item.data:
            return None
        for item in self.item.data:
            text = ""
            for box in item["boxes"]:
                _text = SSEAnswerFormatter._clean_txt(box["text"])
                if _text:
                    text += _text
            if text:
                self.types[text] = {"data": AnswerItem(data=[item], text=text, score=self.item.score)}
        return None

    def sorted_types(self):
        """根据行坐标排序"""
        types = OrderedDict()
        self.types = {k: v for k, v in self.types.items() if v.get("pos")}
        if self.types:
            for text, val in sorted(self.types.items(), key=lambda x: x[-1]["pos"][0]):
                types[text] = val
            self.types = types

    def set_pos(self, key, pos):
        """更新关联类型行列坐标"""
        if key in self.types:
            self.types[key].setdefault("pos", (int(pos[0]), int(pos[1])))

    def generate_range(self):
        lst = list(self.types.items())
        for idx, (_, value) in enumerate(lst):
            yield value["data"], (value["pos"][0], lst[idx + 1][-1]["pos"][0] if idx + 1 < len(lst) else -1)

    def get_item_by_pos(self, pos):
        """按行约束判断属于哪一关联类型"""
        row = pos[0]
        for item, (bottom, top) in self.generate_range():
            if bottom < row < top or top == -1:
                return item
        return None


class Regular:
    def __init__(self, reg, flag=True, multi=False, extra=None):
        self.reg = re.compile(reg)
        self.flag = flag
        self.multi = multi
        self.extra = re.compile(extra) if extra else None


class SSEAnswerFormatter:
    def __init__(self, reader, **kwargs):
        self.reader = reader  # PDFinsight reader obj
        self.file = kwargs.get("file")
        self.schema = kwargs.get("schema")
        self.handlers = {
            "IPO资产负债表（合并）": partial(self._big_table, re_group=True),
            "IPO资产负债表（母公司）": partial(self._big_table, re_group=True),
            "IPO利润表（合并）": partial(self._big_table, re_group=True),
            "IPO利润表（母公司）": partial(self._big_table, re_group=True),
            "IPO现金流量表（合并）": partial(self._big_table, re_group=True),
            "IPO现金流量表（母公司）": partial(self._big_table, re_group=True),
            "概览-主要会计数据及财务指标": partial(self._big_table, re_group=True),
            "财务会计信息-主要财务指标": partial(self._big_table, re_group=True),
            "财务会计信息-研发费用细分情况": self._big_table,
            "财务会计信息-研发费用率与同行业公司对比": partial(self._big_table, unit="%"),
            "公司治理与独立性-关联方及关联关系": self.related_parties,
            # 枚举类型
            "发行人基本情况-重大资产重组情况": partial(
                self._enum_field,
                _enum=["发行人报告期内是否存在重大资产重组"],
                _extra={"重大资产重组情况说明（原文）": "发行人报告期内是否存在重大资产重组"},
            ),
            "发行人基本情况-控股股东": partial(
                self._enum_field,
                _enum=["控股股东类型"],
                _extra={
                    "控股股东持股数量原文": "控股股东持股数量",
                    "控股股东持股数量原文单位": "<数量单位>",
                    "控股股东持股占比原文": "控股股东持股占比",
                },
                _particial={"控股股东持股数量原文单位": AMOUNT_UNIT_PATTERN},
            ),
            "发行人基本情况-实际控制人": partial(
                self._enum_field,
                _enum=["实际控制人类型"],
                _extra={
                    "实际控制人持股数量原文": "实际控制人持股数量",
                    "实际控制人持股数量原文单位": "<数量单位>",
                    "实际控制人持股占比原文": "实际控制人持股占比",
                },
                _particial={"实际控制人持股数量原文单位": AMOUNT_UNIT_PATTERN},
            ),
            "发行人基本情况-实际控制人的一致行动人": partial(
                self._enum_field,
                _enum=["一致行动人类型"],
                _extra={
                    "一致行动人持股数量原文": "一致行动人持股数量",
                    "一致行动人持股数量原文单位": "<数量单位>",
                    "一致行动人持股占比原文": "一致行动人持股占比",
                    "一致行动人情况原文段落": "一致行动人基本情况（原文）",
                },
                _particial={"一致行动人持股数量原文单位": AMOUNT_UNIT_PATTERN},
            ),
            "发行人基本情况-持有5%以上股份的股东": partial(
                self._enum_field,
                _enum=["持股5%以上股东类型"],
                _extra={
                    "持股5%以上股东持股数量原文": "持股5%以上股东持股数量",
                    "持股5%以上股东持股数量原文单位": "<数量单位>",
                    "持股5%以上股东持股占比原文": "持股5%以上股东持股占比",
                },
                _particial={"持股5%以上股东持股数量原文单位": AMOUNT_UNIT_PATTERN},
            ),
            "发行人基本情况-员工持股平台": partial(
                self._enum_field,
                _enum=["是否存在员工持股平台"],
                _extra={"持股平台基本情况（原文）": "是否存在员工持股平台"},
            ),
            "发行人基本情况-控股股东、实际控制人股权质押情况": partial(
                self._enum_field,
                _enum=["是否存在质押或其他有争议的情况"],
                _extra={"质押或其他有争议的说明（原文）": "是否存在质押或其他有争议的情况"},
            ),
            "公司治理与独立性-发行人特别表决权股份情况": partial(
                self._enum_field,
                _enum=["是否存在特别表决权股份"],
                _extra={"特别表决权股份情况（原文）": "是否存在特别表决权股份"},
            ),
            "公司治理与独立性-发行人协议控制架构情况": partial(
                self._enum_field,
                _enum=["是否存在协议控制架构"],
                _extra={"发行人协议控制架构情况（原文）": "是否存在协议控制架构"},
            ),
            "财务会计信息-审计意见": partial(
                self._enum_field, _enum=["审计意见"], _extra={"审计意见（原文）": "审计意见"}
            ),
            "其他重要事项-对外担保情况": partial(
                self._enum_field,
                _enum=["发行人是否存在对外担保"],
                _extra={"对外担保情况（原文）": "发行人是否存在对外担保"},
            ),
            "其他重要事项-重大诉讼": partial(
                self._enum_field, _enum=["是否存在重大诉讼"], _extra={"重大诉讼情况（原文）": "是否存在重大诉讼"}
            ),
            "其他重要事项-涉及违法情况": partial(
                self._enum_field, _enum=["是否存在涉及违法"], _extra={"涉及违法情况（原文）": "是否存在涉及违法"}
            ),
            "其他重要事项-董监高核涉及立案情况": partial(
                self._enum_field,
                _enum=["是否存在涉及立案"],
                _extra={"涉及立案情况（原文）": "董监高核是否存涉及立案", "是否存在涉及立案": "董监高核是否存涉及立案"},
            ),
            "公司治理与独立性-发行人违法违规情况": partial(
                self._enum_field,
                _enum=["是否存在违法违规", "是否属于重大违法违规"],
                _extra={
                    "违法违规情况原文": "是否存在涉及违法",
                    "是否存在违法违规": "是否存在涉及违法",
                    "是否属于重大违法违规": "是否属于重大违法违规",
                },
            ),
            # 项目名称
            "业务与技术-主要产品及业务的收入情况": partial(
                self.fix_project_name,
                project_name="项目(名称/类型)",
                _extra={
                    "收入金额币种": "币种",
                    "收入金额原文": "收入金额",
                    "收入金额原文单位": "<金额单位>",
                    "占收入比例原文": "占收入比例",
                },
            ),
            "财务会计信息-营业收入的构成情况（区分主营与非主营）": partial(
                self.fix_project_name,
                project_name="项目(名称/类型)",
                _extra={
                    "收入金额币种": "币种",
                    "收入金额原文": "收入金额",
                    "收入金额原文单位": "<金额单位>",
                    "占收入比例原文": "占收入比例",
                },
            ),
            "财务会计信息-营业收入分产品分析": partial(
                self.fix_project_name,
                project_name="项目名称",
                _extra={
                    "收入金额原文": "收入金额",
                    "收入金额原文单位": "<金额单位>",
                    "收入金额币种": "币种",
                    "占收入比例原文": "占收入比例",
                },
            ),
            "财务会计信息-营业收入分销售模式分析": partial(
                self.fix_project_name,
                project_name="项目(名称/类型)",
                _extra={
                    "收入金额原文": "收入金额",
                    "收入金额原文单位": "<金额单位>",
                    "收入金额币种": "币种",
                    "占收入比例原文": "占收入比例",
                },
            ),
            "财务会计信息-营业收入分区域分析": partial(
                self.fix_project_name,
                project_name="项目(区域名称/类型)",
                _extra={
                    "收入金额原文": "收入金额",
                    "收入金额原文单位": "<金额单位>",
                    "收入金额币种": "币种",
                    "占收入比例原文": "占收入比例",
                },
            ),
            "财务会计信息-营业收入季节性分析": partial(
                self.fix_project_name,
                project_name="项目(季节名称/类型)",
                _extra={
                    "收入金额原文": "收入金额",
                    "收入金额原文单位": "<金额单位>",
                    "收入金额币种": "币种",
                    "占收入比例原文": "占收入比例",
                },
            ),
            "财务会计信息-营业成本构成情况": partial(
                self.fix_project_name,
                project_name="项目名称(区分主营业务与其他)",
                _extra={
                    "成本金额原文": "成本金额",
                    "成本金额原文单位": "<金额单位>",
                    "成本金额币种": "币种",
                    "占营业成本比原文": "占营业成本比",
                },
            ),
            "财务会计信息-营业成本分产品分析": partial(
                self.fix_project_name,
                project_name="项目名称(名称/类型)",
                _extra={
                    "成本金额原文": "成本金额",
                    "成本金额原文单位": "<金额单位>",
                    "成本金额币种": "币种",
                    "占营业成本比原文": "占营业成本比",
                },
            ),
            "财务会计信息-毛利率及收入占比": partial(
                self.fix_project_name,
                project_name="项目名称(产品/类型)",
                _extra={
                    "项目毛利率": "项目毛利率（%）",
                    "项目毛利率原文": "项目毛利率（%）",
                    "收入占比原文": "收入占比",
                },
            ),
            "募集资金运用与未来发展规划-募集资金用途": partial(
                self.fix_project_name,
                project_name="项目名称",
                _extra={
                    "投资总额币种": "币种",
                    "投资总额原文": "投资总额",
                    "投资总额原文单位": "<金额单位>",
                    "拟投入募集资产币种": "币种",
                    "拟投入募集资产原文": "拟投入募集资产",
                    "拟投入募集资产原文单位": "<金额单位>",
                },
            ),
            "概览-募集资金用途": partial(
                self.fix_project_name,
                project_name="项目名称",
                _extra={
                    "投资总额币种": "币种",
                    "投资总额原文": "投资总额",
                    "投资总额原文单位": "<金额单位>",
                    "拟投入募集资产币种": "币种",
                    "拟投入募集资产原文": "拟投入募集资产",
                    "拟投入募集资产原文单位": "<金额单位>",
                },
            ),
            # 上市标准
            "概览-发行人选择的上市标准": partial(
                self.list_standards, _extra={"发行人选择的上市标准（原文）": "发行人选择的上市标准(原文)"}
            ),
            # 大表格（按行分组）
            "发行人基本情况-股本情况": self.equity_situation,
            "发行人基本情况-前十股东": self.shareholders,
            "发行人基本情况-前十自然人股东及其担任职务": self.natural_shareholders,
            "发行人基本情况-薪酬情况": self.payment_situation,
            "业务与技术-专利": self.patent,
            "业务与技术-软件著作权": self.software_copyright,
            "业务与技术-获奖情况": self.awards,
            "业务与技术-在研项目": self.projects,
            "业务与技术-科研项目": self.sci_projects,
            "业务与技术-发行人参与制定的标准": self.standards,
            "业务与技术-前五客户": self.customers,
            "业务与技术-前五供应商": self.suppliers,
            "业务与技术-科研成果": self.research_achievements,
            "业务与技术-主要核心技术": self.core_tech,
            "业务与技术-专业资质情况": self.professional_qual,
            "扉页-发行概况": partial(self.simple_table, _extra={"每股面值币种": "币种"}),
            "概览-发行概况（二）": partial(
                self.simple_table, _extra={"每股面值币种": "币种", "每股发行价格币种": "币种"}
            ),
            "本次发行概况-发行概况（三）": partial(
                self.simple_table, _extra={"预测净利润币种": "币种", "每股面值币种": "币种", "每股发行价格币种": "币种"}
            ),
            "发行人基本情况-基本情况": partial(
                self.simple_table,
                _extra={
                    "注册资本原文": "注册资本",
                    "注册资本原文单位": "注册资本",
                    "实收资本原文": "实收资本",
                    "实收资本原文单位": "实收资本",
                },
            ),
            "概览-简要基本情况": self.simple_table,
            "概览-中介机构列表": self.simple_table,
            "子公司基本情况": self.third_word_unit,
            "财务会计信息-股份支付概况": self.share_payment,  # 补充`股份支付金额`
            # 细标的二级字段
            "业务与技术-研发人员数量": partial(
                self.label_detail,
                _extra={
                    "研发人员数量占公司总人数比例": "研发人员数量占公司总人数比例(%)",
                    "研发人员数量占公司总人数比例原文": "研发人员数量占公司总人数比例(%)",
                },
            ),
            "财务会计信息-非经常性损益": self.label_detail,
            "业务与技术-研发费用与营业收入比例": partial(
                self.label_detail,
                _extra={
                    "费用化研发投入原文": "费用化研发投入",
                    "费用化研发投入原文单位": "<金额单位>",
                    "费用化研发投入币种": "币种",
                    "资本化研发投入原文": "资本化研发投入",
                    "资本化研发投入原文单位": "<金额单位>",
                    "资本化研发投入币种": "币种",
                    "研发投入合计原文": "研发投入合计",
                    "研发投入合计原文单位": "<金额单位>",
                    "研发投入合计币种": "币种",
                    "营业收入原文": "营业收入",
                    "营业收入原文单位": "<金额单位>",
                    "营业收入币种": "币种",
                    "研发投入占营业收入的比例原文": "研发投入占营业收入的比例",
                },
                _particial={
                    "费用化研发投入原文单位": AMOUNT_UNIT_PATTERN,
                    "资本化研发投入原文单位": AMOUNT_UNIT_PATTERN,
                    "研发投入合计原文单位": AMOUNT_UNIT_PATTERN,
                    "营业收入原文单位": AMOUNT_UNIT_PATTERN,
                },
            ),
            "发行人基本情况-股东关系": self.label_detail,
            "发行人基本情况-董事会成员": self.label_detail,
            "发行人基本情况-监事会成员": self.label_detail,
            "发行人基本情况-高级管理人员": self.label_detail,
            "发行人基本情况-核心技术人员": self.label_detail,
            "发行人基本情况-参股公司基本情况": partial(
                self.label_detail,
                _extra={
                    "注册资本原文": "注册资本",
                    "注册资本原文单位": "注册资本",
                    "实收资本原文": "实收资本",
                    "实收资本原文单位": "实收资本",
                },
                _particial={"注册资本原文单位": AMOUNT_UNIT_PATTERN, "实收资本原文单位": AMOUNT_UNIT_PATTERN},
            ),
            "发行人基本情况-董监高核薪酬总额": partial(
                self.label_detail,
                _extra={
                    "董监高核薪酬总额原文": "董监高核薪酬总额",
                    "董监高核薪酬总额原文单位": "<金额单位>",
                    "董监高核薪酬总额币种": "币种",
                    "利润总额原文": "利润总额",
                    "利润总额原文单位": "<金额单位>",
                    "利润总额币种": "币种",
                    "薪酬总额占利润总额的比重": "薪酬总额占利润总额的比重(%)",
                    "薪酬总额占利润总额的比重原文": "薪酬总额占利润总额的比重(%)",
                },
                _particial={"董监高核薪酬总额原文单位": AMOUNT_UNIT_PATTERN, "利润总额原文单位": AMOUNT_UNIT_PATTERN},
            ),
            "发行人基本情况-员工情况-专业构成": partial(
                self.label_detail, _extra={"专业": "项目（专业）", "占总人数的比例原文": "占总人数的比例"}
            ),
            "发行人基本情况-员工情况-学历构成": partial(
                self.label_detail, _extra={"学历": "项目（学历）", "占总人数的比例原文": "占总人数的比例"}
            ),
            "发行人基本情况-员工情况-年龄构成": partial(
                self.label_detail,
                _extra={"人数": "期末人数", "年龄": "年龄类别/年龄", "占总人数的比例原文": "占总人数的比例"},
            ),
            "业务与技术-核心技术产品占营业收入比例": partial(
                self.label_detail,
                _extra={
                    "核心技术收入原文": "核心技术收入",
                    "核心技术收入原文单位": "<金额单位>",
                    "核心技术收入币种": "币种",
                    "核心技术收入占营业收入比例原文": "核心技术收入占营业收入比例",
                    "核心技术收入占主营业务收入比例原文": "核心技术收入占主营业务收入比例",
                },
                _particial={"核心技术收入原文单位": AMOUNT_UNIT_PATTERN},
            ),
            "公司治理与独立性-同业竞争": self.label_detail,
            "公司治理与独立性-关联交易": self.label_detail,
            "财务会计信息-重要会计政策和会计评估": self.label_detail,
            "财务会计信息-净资产收益率和每股收益": partial(
                self.label_detail,
                _extra={
                    "加权平均净资产收益率": "加权平均净资产收益率（%）",
                    "加权平均净资产收益率原文": "加权平均净资产收益率（%）",
                    "基本每股收益原文单位": "<每股收益单位>",
                    "稀释每股收益原文单位": "<每股收益单位>",
                },
            ),
            "本次发行概况-相关机构-保荐人": self.label_detail,
            "本次发行概况-相关机构-主承销商": self.label_detail,
            "本次发行概况-相关机构-发行人律师事务所": self.label_detail,
            "本次发行概况-相关机构-保荐人律师事务所": self.label_detail,
            "本次发行概况-相关机构-审计机构": self.label_detail,
            "本次发行概况-相关机构-资产评估机构": self.label_detail,
            "本次发行概况-相关机构-资产评估复核机构": self.label_detail,
            "本次发行概况-相关机构-验资机构": self.label_detail,
            "本次发行概况-相关机构-验资复核机构": self.label_detail,
            "本次发行概况-相关机构-存托机构": self.label_detail,
            "本次发行概况-相关机构-托管机构": self.label_detail,
            "本次发行概况-其他相关机构": self.label_detail,
            "风险因素": self.label_detail,
            "发行人基本情况-分支机构基本情况": self.label_detail,
            "扉页-重大事项提示": self.label_detail,
            "发行人基本情况-发行人股权结构图": self.sharehold_chart,
        }

    def format(self, answer, need_page_no=True, re_groups=()):
        result = OrderedDict()

        def _for_each_node(path, node):
            res = OrderedDict()
            page_noes = []
            for key, val in node.items():
                if not val:
                    continue
                sub_node_path = path + [key]
                col_name = "_".join(sub_node_path)
                if "_" not in col_name:
                    page_noes.clear()
                if col_name in self.handlers:
                    # 特殊处理方法
                    if col_name not in re_groups:
                        handler_res = self.handlers[col_name](val, res=res, node=node, col_name=col_name)
                    else:
                        handler_res = self.handlers[col_name](val, res=res, node=node, col_name=col_name, re_group=True)
                    if handler_res:
                        if isinstance(handler_res, tuple):
                            res[key] = handler_res[0]
                            page_noes += handler_res[1]
                        else:
                            res[key] = handler_res
                elif isinstance(val, AnswerItem):
                    # 叶子节点，输出值
                    _text, _page_noes = self._table_and_text(val)
                    if val and val.data:
                        res[key] = gen_result_struct(
                            item_data=[LabelResult(items=val.data, text=_text)], score=val.score
                        )
                else:
                    # 非叶子节点，输出 [{}, ...]
                    res[key] = []
                    sorted_sub_nodes = [x[1] for x in sorted(val.items(), key=lambda item: int(item[0]))]
                    _replenish_sub_nodes(sorted_sub_nodes)
                    for sub_node in sorted_sub_nodes:
                        sub_res, _page_noes = _for_each_node(sub_node_path, sub_node)
                        res[key].append(sub_res)
                        page_noes += _page_noes
                    if page_noes:
                        res[key].insert(0, {"page_no": str(sorted(page_noes)[0]) if page_noes else ""})

            return res, page_noes

        def _replenish_sub_nodes(node_list):
            """自动补充重复的节点"""
            auto_replenish_node_names = [
                "<金额单位>",
                "<百分比单位>",
                "<每股收益单位>",
                "<数量单位>",
                "股份支付金额原文单位",
            ]
            if node_list is None or len(node_list) < 2:
                return
            node_1st = node_list[0]
            if not isinstance(node_1st, dict):
                return
            for node in node_list[1:]:
                for replenish_node in auto_replenish_node_names:
                    if not node.get(replenish_node) and node_1st.get(replenish_node):
                        node[replenish_node] = node_1st[replenish_node]

        answer_tree = load_scriber_answer(answer)
        if answer_tree:
            root_node = list(answer_tree.values())[0]
            result, _ = _for_each_node([], root_node)
        result = self.revise(result, need_page_no)
        return result

    @staticmethod
    def convert_answer_item(val):
        if isinstance(val, AnswerItem):  # 直接从转换好的答案生成
            _text = ""
            for each in val.data:
                if isinstance(each, str):
                    _text += each
                else:
                    if each.get("text"):
                        _text += each["text"]
                    else:
                        _text += "".join([box["text"] for box in each.get("boxes", [])])
            val = gen_result_struct(
                item_data=[LabelResult(items=val.data, text=_text)], value=val.value, score=val.score
            )
        return val

    @staticmethod
    def gen_financial_year(json_answer):
        """
        :param json_answer:
        :return: ResultOfPredictor or None
        """
        possible_attrs = [
            "IPO资产负债表（合并）",
            "IPO资产负债表（母公司）",
            "IPO利润表（合并）",
            "IPO利润表（母公司）",
            "IPO现金流量表（合并）",
            "IPO现金流量表（母公司）",
            "概览-主要会计数据及财务指标",
            "财务会计信息-主要财务指标",
        ]
        for attr in possible_attrs:
            if attr not in json_answer:
                continue
            fy_list = [
                res_dict["年度"]
                for res_dict in json_answer[attr]
                if isinstance(res_dict, OrderedDict) and res_dict.get("年度") and res_dict["年度"].data
            ]
            if fy_list:
                return sorted(fy_list, key=lambda x: x.data[0].text, reverse=True)[0]
        logging.warning("Financial year info not found.")
        return None

    @classmethod
    def revise(cls, json_answer, need_page_no=True):
        """标准化输出：值类型转换，日期类型，"""
        financial_year = cls.gen_financial_year(json_answer)

        def _for_each_node(node, path):
            res = OrderedDict()
            for key, val in node.items():
                key = str(key)
                sub_node_path = path + [key]
                if key.startswith("<") or key.startswith(">") or key.startswith("（"):
                    continue
                if isinstance(val, list):
                    res[key] = []
                    for _item in val:
                        if isinstance(_item, dict) and not isinstance(_item, AnswerItem):
                            _item_res = _for_each_node(_item, sub_node_path)
                            if any(v for v in _item_res.values() if v is not None):
                                # 过滤掉全部为 None 的 dict
                                res[key].append(_item_res)
                        else:
                            res[key].append(_revise(_item, sub_node_path, node))
                elif isinstance(val, dict) and not isinstance(val, AnswerItem):
                    res[key] = _for_each_node(val, sub_node_path)
                elif val is None:
                    res[key] = _revise(financial_year, sub_node_path, node) if key == "年度" else None
                elif key == "page_no":
                    if need_page_no:
                        res[key] = val
                else:
                    res[key] = _revise(val, sub_node_path, node)
            return res

        def _revise(val, path, parent_node):
            if not val or not (val.data or val.value):
                return val
            # if val.value and not val.data:  # 枚举类型的文本用原文补充
            #     for k, v in parent_node.items():
            #         if '原文' in k and v:
            #             val.data = v.data
            #             break
            val = deepcopy(cls.convert_answer_item(val))
            # print(777, path, [(x.text, ) for x in val.data if x])
            if "原文" in path[-1]:
                return val
            for _revise_handler in [_revise_unit, _revise_number, _revise_datetime, _revise_text, _revise_segement]:
                flag = False
                for each in val.data:
                    if not each:
                        continue
                    _text = each.text
                    if not isinstance(_text, str):
                        continue
                    _res = _revise_handler(_text, path=path, parent_node=parent_node)
                    if _res is not None:
                        # print(888, _text, _revise_handler, _res)
                        flag = True
                        each.text = _res
                        # if hasattr(each, 'items'):
                        #     for item in each.items:
                        #         item['text'] = _res
                        break
                if flag:
                    break
            return val

        def _revise_unit(text, path=None, parent_node=None, **kwargs):
            _key = path[-1]
            if re.search(r"单位>?$", _key) and "元" in text:  # 修正单位
                return "元"
            return None

        def _revise_number(text, path=None, parent_node=None, **kwargs):
            text = remove_whitespace(text)
            _clean = [
                re.compile(r"[(（\[【]注.*[)）\]】]$"),  # 18.56（注 4）
                re.compile(r"^约\s*"),  # 约650万
                re.compile("人民币|[港欧美日韩]元"),  # 100万元人民币
            ]
            for anno_reg in _clean:
                if anno_reg.search(text):
                    text = anno_reg.sub("", text)
            text = text.strip("()（）")
            _key = path[-1]
            ignore_keys = [
                re.compile(r"^项目(名称)?$"),
                re.compile(r"倍数?$"),  # 对应"利息保障倍数"
                re.compile(r"^项目[(（【\[].*[)）\]】]"),
                re.compile(r"[序编代文][号码]"),
                re.compile(r"专利号"),
                re.compile(r"人数"),
                date_attr_reg,
            ]
            if any(reg.search(_key) for reg in ignore_keys):
                return None
            val_str, unit = split_number_and_unit(text)
            if not val_str:
                return None
            val_str = val_str.replace(",", "")
            # val = float(val_str) if "." in val_str else int(val_str)
            val = Decimal(val_str)

            if not unit and parent_node:
                if path and parent_node.get("%s原文单位" % path[-1]):
                    unit = parent_node.get("%s原文单位" % path[-1])
                elif re.search(r"率|比[重例]|利率|占.*比", _key):
                    unit = parent_node.get("<百分比单位>")
                elif re.search(r"数量", _key):
                    unit = parent_node.get("<数量单位>")
                elif re.search(r"每股", _key):
                    unit = parent_node.get("<每股收益单位>")
                elif "<金额单位>" in parent_node:
                    unit = parent_node["<金额单位>"]
                elif "单位" in parent_node:
                    unit = parent_node["单位"]
                elif "股份支付金额原文单位" in parent_node:
                    unit = parent_node["股份支付金额原文单位"]
                unit = unit.data[0].text if isinstance(unit, ResultOfPredictor) and unit.data and unit.data[0] else ""
            if not unit:
                unit = ""
            if isinstance(unit, list):
                unit = "_".join(unit)
            ignore_units = re.compile(r"岁|年|月|日(?!元)")
            if ignore_units.search(unit):
                return None

            multipliers = {
                "十": 10,
                "拾": 10,
                "百": 100,
                "佰": 100,
                "千": 1000,
                "仟": 1000,
                "万": 10000,
                "亿": 100000000,
            }
            multi = 1
            for word in unit:
                if word in multipliers:
                    multi *= multipliers[word]
            # 按原数据格式取有效数字
            return (val * multi).quantize(val, rounding=ROUND_HALF_UP).to_eng_string()

        def remove_whitespace(text):
            return text.replace(" ", "")

        def pathname(path):
            return "_".join(path or [])

        def split_number_and_unit(text):
            res = re.match(r"^(?P<val>-?\d+(,\d+)*(\.\d+)?)(?P<unit>\D{0,4})$", text)
            if res:
                return res.group("val"), res.group("unit")
            return None, None

        def _revise_datetime(text, path=None, parent_node=None, **kwargs):
            text = remove_whitespace(text)
            _pathname = pathname(path)
            _key = path[-1]
            ignore_keys = [re.compile(r"任期"), re.compile(r"招股说明书签署日期")]
            if any(reg.search(_key) for reg in ignore_keys):
                return None
            date_attrs = []
            if not text or not (_pathname in date_attrs or date_attr_reg.search(_key)):
                return None
            # print('~~~~~', path, parent_node, text)
            date_regs = [
                re.compile(r"(?P<year>\d{4}年度?)(?P<month>\d{1,2}[-]\d{1,2}月份?)"),
                re.compile(r"(?P<year>\d{4})(年度?|\.|-|/)?((?P<month>\d{1,2})(月份?|\.|-|/)?((?P<day>\d+)[日号]?)?)?"),
            ]
            fmt_map = [[("year", "{}"), ("month", "{}")], [("year", "{}"), ("month", "-{:0>2}"), ("day", "-{:0>2}")]]
            for reg, fmt in zip(date_regs, fmt_map):
                matched = reg.search(text)
                if not matched:
                    continue
                res = []
                for k, v in fmt:
                    if matched.groupdict().get(k):
                        res.append(v.format(matched.group(k)))
                if res:
                    # return '%s  => %s' % (text, ''.join(res))
                    return "".join(res)
            return None

        def _revise_text(text, path=None, parent_node=None, **kwargs):
            text = remove_whitespace(text)
            _key = path[-1]
            sensitive_attrs = ("专利授权国家",)
            replace_map = {
                "香港": "中国香港",
                "澳门": "中国澳门",
                "澳門": "中国澳门",
                "台湾": "中国台湾",
                "大陆": "中国大陆",
                "境内": "中国",
                "内地": "中国",
            }
            # 敏感词替换
            if _key in sensitive_attrs and text in replace_map:
                return replace_map.get(text, text)
            # 币种缺失, 默认人民币
            if _key == "币种" and not text:
                return "人民币"
            # 金额换算完毕后需要将单位改为'元'
            if _key == "单位" and any((i in text for i in ("十", "百", "千", "万", "亿"))):
                return "元"
            return None

        def _revise_segement(text, path=None, parent_node=None, **kwargs):
            return None

        json_answer = _for_each_node(json_answer, [])
        # _for_each_node(json_answer, [])

        return json_answer

    def _enum_field(self, item_dict, **kwargs):
        """
        枚举类型
        """
        res = []
        page_noes = []
        export_attrs = self.schema.schema_dict.get(kwargs.get("col_name"), {}).get("orders", [])  # 需要导出的字段
        _extra = kwargs.get("_extra", {})
        _enum = kwargs.get("_enum", [])
        _particial = kwargs.get("_particial", {})
        for _, grp in sorted(item_dict.items(), key=lambda item: int(item[0])):
            # if _ not in [0, ]:
            #     continue
            item = {}
            for _attr in export_attrs:
                attr = _extra[_attr] if _attr in _extra else _attr
                val = deepcopy(grp.get(attr) or grp.get(re.sub(r"原文单位$", "", _attr)))  # 尝试从原文中取单位
                # print('-------', _attr, attr)
                if not val or not (val.data or val.value):
                    item[_attr] = None
                elif _attr in _enum:  # 枚举值
                    item[_attr] = gen_result_struct(item_data=[], value=val.value, score=val.score)
                else:  # 普通字段
                    _text = val.simple_text(enum=False)
                    if isinstance(_text, str):
                        _text = get_num_from_chars(_text, _particial.get(_attr))
                        item[_attr] = gen_result_struct(
                            item_data=[LabelResult(items=val.data, text=_text)], value=val.value, score=val.score
                        )
                    elif isinstance(_text, list):
                        # _text = [get_num_from_chars(x, _particial.get(_attr)) for x in _text]
                        item[_attr] = gen_result_struct(
                            item_data=[LabelResult(items=val.data)], value=val.value, score=val.score
                        )
                if val and val.data:
                    page_noes += [box["page"] for box in val.data[0]["boxes"]]
            res.append(item)
        return res

    @staticmethod
    def _clean_txt(txt, is_num=False, all_space=True):
        if not all_space:
            ret = re.sub(r"(?<![。；;a-zA-Z])\n", "", txt.strip())
        else:
            ret = re.sub(r"\s|\n+", "", txt.strip())  # 删空格/回车符
        ret = re.sub(r"注\d+$", "", ret).strip()  # 删尾注, 如"xxx公司 注1"
        if is_num:
            ret = re.sub(r"，|,|%+", "", ret)  # 去百分号/逗号
            ret = re.sub(r"（.*）", "", ret).strip()  # 去类似"（1-5月）"的月份信息
            try:
                float(ret)
            except ValueError:
                ret = None  # 金额默认为空
        return ret

    @staticmethod
    def _sorted_cells(cells, reverse=False):
        sorted_d = sorted(cells.items(), key=lambda k_v: int(k_v[0]), reverse=reverse)
        return OrderedDict(sorted_d)

    def _get_unit(self, item_data):
        """提取金额单位(有可能会有多个单位, 这里只取一个)"""
        for label_data in item_data:
            for box_info in label_data.get("boxes"):
                if box_info["text"]:
                    return LabelResult(items=item_data, text=self._clean_txt(box_info["text"]))
        return LabelResult(items=item_data, text="")

    def _get_elements(self, item_data):
        """根据outline拿到元素块信息"""
        elements = []
        for label_data in item_data:
            for box_info in label_data.get("boxes"):
                page = box_info["page"]
                box = box_info["box"]
                outline = box_to_outline(box)
                elts = self.reader.find_elements_by_outline(page, outline)
                for _type, element in elts:
                    elements.append(element)
        return elements

    # 以下开始定义格式化方法
    def _simple_text_for_node(self, val, clear=True):
        """默认，直接输出 text"""
        page_noes = []
        texts = val.simple_text(clear)
        if val:
            page_noes += [box["page"] for data in val.data for box in data["boxes"]]
        return texts, page_noes

    def _table_and_text(self, val, join=True):
        page_noes = []
        if not val or not val.data:
            return None, page_noes
        res = []

        def aim_to_some_chars(element, box_outline):
            return PdfinsightReader.overlap_percent(element["outline"], box_outline, base="element") < 0.8

        page_noes += [box["page"] for data in val.data for box in data["boxes"]]
        for label_data in val.data:
            for box_info in label_data.get("boxes"):
                label_text = box_info.get("text", "")
                page = box_info["page"]
                box = box_info["box"]
                outline = box_to_outline(box)
                elts = self.reader.find_elements_by_outline(page, outline)
                for _type, element in elts:
                    if element.get("page_merged_table"):
                        continue
                    if _type == "TABLE":
                        # 表格有两种标注情况：cell | table
                        if any(
                            self._clean_txt(cell.get("text")) == self._clean_txt(label_text)
                            for cell in element.get("cells", {}).values()
                        ) or aim_to_some_chars(element, outline):
                            text = label_text
                        else:
                            text = self.table2md(element.get("cells"))
                        if text and text not in res:  # 跨页表格可能重复导出
                            res.append(text)
                    elif element.get("text"):
                        # 段落有两种标注情况：部分 | 全部
                        para_text = element.get("text", "")
                        text = (
                            label_text
                            if label_text
                            and self._clean_txt(label_text) in self._clean_txt(para_text)
                            or aim_to_some_chars(element, outline)
                            else para_text
                        )
                        if text:
                            res.append(re.sub(r"[\n\r]", "", text))
                            res.append("\n")
        return "".join(res) if join else res, page_noes

    def list_standards(self, item_dict, **kwargs):
        """
        概览-发行人选择的上市标准
        如果编号不完整，输出时需要补全编号
        内容需要自动替换成41号文件中的规范内容
        """

        listing_rules = {
            (
                "2.1.2",
                "一",
                "预计市值不低于人民币10亿元，最近两年净利润均为正且累计净利润不低于人民币5000万元，或者预计市值不低于人民币10亿元，最近一年净利润为正且营业收入不低于人民币1亿元；",
            ): r"预计市值不低于人民币10亿元.最近两年净利润均为正且累计净利润不低于人民币5[,，]?000万元.或者预计市值不低于人民币10亿元.最近一年净利润为正且营业收入不低于人民币1亿元",
            (
                "2.1.2",
                "二",
                "预计市值不低于人民币15亿元，最近一年营业收入不低于人民币2亿元，且最近三年累计研发投入占最近三年累计营业收入的比例不低于15%；",
            ): "预计市值不低于人民币15亿元，最近一年营业收入不低于人民币2亿元.且最近三年累计研发投入占最近三年累计营业收入的比例不低于15%",
            (
                "2.1.2",
                "三",
                "预计市值不低于人民币20亿元，最近一年营业收入不低于人民币3亿元，且最近三年经营活动产生的现金流量净额累计不低于人民币1亿元；",
            ): "预计市值不低于人民币20亿元.最近一年营业收入不低于人民币3亿元.且最近三年经营活动产生的现金流量净额累计不低于人民币1亿元",
            (
                "2.1.2",
                "四",
                "预计市值不低于人民币30亿元，且最近一年营业收入不低于人民币3亿元；",
            ): "预计市值不低于人民币30亿元.且最近一年营业收入不低于人民币3亿元",
            (
                "2.1.2",
                "五",
                "预计市值不低于人民币40亿元，主要业务或产品需经国家有关部门批准，市场空间大，目前已取得阶段性成果。医药行业企业需至少有一项核心产品获准开展二期临床试验，其他符合科创板定位的企业需具备明显的技术优势并满足相应条件。",
            ): "预计市值不低于人民币40亿元.主要业务或产品需经国家有关部门批准.市场空间大.目前已取得阶段性成果.医药行业企业需至少有一项核心产品获准开展二期临床试验.其他符合科创板定位的企业需具备明显的技术优势并满足相应条件",
            ("2.1.3", "一", "预计市值不低于人民币100亿元；"): "预计市值不低于人民币100亿元",
            (
                "2.1.3",
                "二",
                "预计市值不低于人民币50亿元，且最近一年营业收入不低于人民币5亿元。",
            ): "预计市值不低于人民币50亿元.且最近一年营业收入不低于人民币5亿元",
        }

        res = []
        page_noes = []

        export_attrs = self.schema.schema_dict.get(kwargs.get("col_name"), {}).get("orders", [])  # 需要导出的字段
        _extra = kwargs.get("_extra", {})  # 5 => 4 字段对应关系
        for _, grp in sorted(item_dict.items(), key=lambda item: int(item[0])):
            item = {}
            for _attr in export_attrs:
                attr = _extra[_attr] if _attr in _extra else _attr
                val = deepcopy(grp.get(attr))
                if not val or not val.data:
                    item[_attr] = None
                    continue
                text = val.simple_text()
                text = clean_txt(text if isinstance(text, str) else "".join(text))
                item[_attr] = gen_result_struct(item_data=[LabelResult(items=val.data, text=text)], score=val.score)
                page_noes += [box["page"] for box in val.data[0]["boxes"]]

            # 条款编号 & 内容
            base = item.get("发行人选择的上市标准（原文）")
            if base:
                text = base.data[0].text
                for k, v in listing_rules.items():
                    code1, code2, rule = k
                    regs = [r"%s.*?[第(（\[【]+%s[)）\]】套项条款]+" % (code1, code2), v]
                    matched = any(re.search(reg, text) for reg in regs)
                    if matched:
                        item["发行人选择的上市标准-条款编号"] = gen_result_struct(
                            item_data=[LabelResult(items=[], text="%s（%s）" % (code1, code2))], score=base.score
                        )
                        item["发行人选择的上市标准-内容"] = gen_result_struct(
                            item_data=[LabelResult(items=[], text=rule)], score=base.score
                        )
            res.append(item)
        if page_noes:
            res.insert(0, {"page_no": str(sorted(page_noes)[0])})
        return res

    def gen_md_tbl_str(self, tbl):
        res = []
        cells_by_row, cells_by_col = group_cells(tbl["cells"])
        for row in sorted(cells_by_row, key=int):  # 从上到下
            cells = cells_by_row.get(str(row))
            _texts = []
            for col in sorted(cells, key=int):  # 从左到右
                cell = cells.get(str(col))
                if not cell:
                    continue
                _texts.append("| %s " % self._clean_txt(cell["text"]))
            _texts.append("|\n")
            row_text = "".join(_texts)
            res.append(row_text)
        line_row = []  # 表头分割线
        for _ in cells_by_row.get("0", {}):
            line_row.append("|:---")
        line_row.append("|\n")
        res[1:1] = "".join(line_row)
        # with open('/Users/mxt/Downloads/ttt2.md', 'w') as mdf:
        #     print(''.join(res))
        #     mdf.write(''.join(res))
        return "".join(res)

    def row_group(
        self,
        item_dict,
        col_attr,
        tbl_attr,
        pass_rows=None,
        time_key=None,
        grp_key=None,
        mid_attr=None,
        name="",
        _extra=None,
    ):
        mid_attr = mid_attr if mid_attr else []  # mid row作为公用属性的情况
        _extra = _extra or {}

        def _marked_tbl(group):
            # 判断标注是否为大表格
            for attr, val in group.items():
                if not re.search(r"表格", attr):
                    continue
                if not val or not val.data:
                    continue
                for each in val.data:
                    for box_info in each.get("boxes"):
                        page = box_info["page"]
                        box = box_info["box"]
                        outline = box_to_outline(box)
                        _type, elt = self.reader.find_element_by_outline(page, outline)
                        if elt is not None and _type == "TABLE":
                            return elt, val.score
            return None, None

        def get_tbl_time(tbl_idx, score=None):
            """
            表格上方的时间
            """
            prev_elts = self.reader.find_elements_near_by(tbl_idx, step=-1, amount=3)
            for elt in prev_elts:
                if elt["class"] == "PARAGRAPH":
                    for item in re.finditer(DATE_PATTERN, elt["text"]):
                        label = item.group()
                        chars = elt["chars"][item.start() : item.end()]
                        return gen_result_struct(item_data=[CharResult(chars=chars, text=label)], score=score)
            return None

        def deal_mid_row(cells, score=None):
            cells = [cell for cell in cells.values() if not cell.get("dummy")]
            _texts = {self._clean_txt(cell["text"]) for cell in cells if self._clean_txt(cell["text"])}
            # print(len(cells), _texts, len(_texts) == 1 and len(cells) == 1)
            res = {}
            if len(_texts) == 1 and len(cells) == 1:
                _text = list(_texts)[0]
                if re.search(DATE_PATTERN, _text):
                    res.update(
                        {
                            "时间": gen_result_struct(
                                item_data=[CharResult(chars=cells[0]["chars"], text=_text)], score=score
                            )
                        }
                    )
                else:
                    for attr, regs in mid_attr:
                        if not grp.get(attr):
                            continue
                        for each in grp[attr].data:
                            for box_info in each.get("boxes", []):
                                box_text = self._clean_txt(box_info.get("text", ""))
                                # print(box_text, _text)
                                # 标注的文本和mid_row中的文本相同
                                if any(re.search(reg, box_text) for reg in regs) and _text == box_text:
                                    res.update(
                                        {
                                            attr: gen_result_struct(
                                                item_data=[CharResult(chars=cells[0]["chars"], text=_text)], score=score
                                            )
                                        }
                                    )
                return True, res
            return False, res

        res = []
        page_noes = []
        serial_number = re.compile(r"^[序编][号码]$")
        export_attrs = self.schema.schema_dict.get(name, {}).get("orders", [])  # 需要导出的字段
        for _, grp in sorted(item_dict.items(), key=lambda item: int(item[0])):
            cur_grp_key = deepcopy(grp_key)
            items = []
            # if _ not in [0, ]:
            #     continue
            # print('--------', _, grp)
            tbl, tbl_score = _marked_tbl(grp)
            if tbl:  # 标注了大表格
                # print(tbl['page'], tbl['index'])
                cells_by_row, cells_by_col = group_cells(tbl["cells"])
                cur_col_attr, cur_tbl_attr = deepcopy(col_attr), deepcopy(tbl_attr)
                for col, cell in cells_by_row.get("0", {}).items():
                    if serial_number.search(self._clean_txt(cell["text"])):
                        cur_col_attr["序号"] = col
                        break
                for _attr in export_attrs:
                    attr = _extra[_attr] if _attr in _extra else _attr
                    val = grp.get(attr)
                    if not val or not val.data:
                        continue
                    page_noes += [box["page"] for box in val.data[0]["boxes"]]
                    # print('====', attr, val.data)
                    if attr in col_attr:  # cell中的属性
                        aim_col = []
                        for each in val.data:
                            for box_info in each.get("boxes"):
                                box = box_info["box"]
                                outline = box_to_outline(box)
                                _, elt = self.reader.find_element_by_outline(box_info["page"], outline)
                                if not elt:
                                    continue
                                if not (elt["index"] == tbl["index"] or tbl.get("cells") == elt.get("cells")):
                                    continue
                                aim_cell_idx = self.reader.find_cell_idx_by_outline(tbl, outline, box_info["page"])
                                if aim_cell_idx:
                                    if tbl["cells"].get(aim_cell_idx, {}).get("dummy"):
                                        continue
                                    row, col = aim_cell_idx.split("_")
                                    is_mid_row, _ = deal_mid_row(cells_by_row.get(str(row)), score=tbl_score)
                                    # print('!!!!!!', aim_cell_idx, is_mid_row)
                                    if not is_mid_row and col not in aim_col:
                                        aim_col.append(col)
                        if aim_col:
                            cur_col_attr[_attr] = aim_col
                        else:
                            cur_col_attr.setdefault(_attr, None)
                    if attr in tbl_attr:  # table公用的属性
                        # cur_tbl_attr[attr] = self._simple_text(val)
                        cur_tbl_attr[_attr] = gen_result_struct(
                            item_data=[LabelResult(items=val.data, text=val.simple_text())], score=val.score
                        )

                pass_regs = None
                if pass_rows:
                    pass_regs = [re.compile(_str) for _str in pass_rows]
                # print('===========', cur_col_attr,
                #       {k: [x.text for x in v.data] for k, v in cur_tbl_attr.items() if v}, pass_regs)
                tbl_time = get_tbl_time(tbl["index"], score=tbl_score)
                mid_row_info = {}
                if any(len(cur_col_attr[x]) > 2 for x in cur_col_attr if cur_col_attr[x] is not None):
                    # todo: 3列以上的表头
                    continue
                for row in sorted(cells_by_row, key=int):  # 从上到下
                    group = dict.fromkeys(list(cur_col_attr.keys()) + list(tbl_attr.keys()))
                    # 补充单位
                    for attr in UNITS:
                        _val = grp.get(attr)
                        if _val and _val.data:
                            group[attr] = gen_result_struct(
                                item_data=[LabelResult(items=_val.data, text=_val.simple_text())],
                                score=_val.score,
                            )

                    cells = cells_by_row.get(str(row))
                    # print('-------', row, {k: v['text'] for k, v in cells.items()})
                    # 需要跳过的行
                    if pass_regs:
                        if any(
                            reg.search(self._clean_txt(cell["text"])) for cell in cells.values() for reg in pass_regs
                        ):
                            # print('pass row ...')
                            continue
                    # mid_row
                    b_mid_row, _ = deal_mid_row(cells, score=tbl_score)
                    if b_mid_row:
                        mid_row_info = _
                        # print('b_mid_row ...', {k: [x.text for x in v.data] for k, v in mid_row_info.items()})
                        continue
                    # 提取数据
                    for col in sorted(cells, key=int):  # 从左到右
                        cell = cells.get(str(col))
                        if not cell:
                            continue
                        for attr in cur_col_attr:
                            if not cur_col_attr[attr]:
                                continue
                            if col in cur_col_attr[attr]:
                                _text = self._clean_txt(cell["text"], all_space=False)
                                if not _text:
                                    continue
                                if group.get(attr) is None:
                                    group[attr] = gen_result_struct(
                                        item_data=[CharResult(chars=cell["chars"], text=_text)], score=tbl_score
                                    )
                                else:
                                    group[attr].data.append(CharResult(chars=cell["chars"], text=_text))

                    # 补充时间信息
                    if time_key in col_attr:
                        if not group.get(time_key):
                            group[time_key] = None
                            for _time in [mid_row_info.get("时间"), tbl_time]:
                                if _time:
                                    group[time_key] = _time
                                    break
                        mid_row_info["时间"] = group[time_key]

                    # mid_attr
                    for attr, _ in mid_attr:
                        if group.get(attr) is None and mid_row_info.get(attr) is not None:
                            group[attr] = mid_row_info[attr]

                    # tbl_attr
                    for attr in tbl_attr:
                        group.setdefault(attr, None)
                        if (
                            group.get(attr) is None
                            and cur_col_attr.get(attr) is None
                            and cur_tbl_attr.get(attr) is not None
                        ):
                            group[attr] = cur_tbl_attr[attr]

                    if group:
                        cur_grp_key = [] if not cur_grp_key else cur_grp_key
                        if cur_col_attr.get("序号") is not None and "序号" not in cur_grp_key:
                            cur_grp_key.append("序号")
                        tmp_group = {k: [x.text for x in v.data] for k, v in group.items() if v and v.data}
                        # print(cur_grp_key, tmp_group)
                        if not items:
                            items.append(group)
                            continue
                        if not all(k in tmp_group for k in cur_grp_key) and cur_col_attr.get("序号") is not None:
                            lst_group = items[-1]
                            for k, v in group.items():
                                text_1 = (
                                    lst_group[k].data[-1].text
                                    if isinstance(lst_group[k], ResultOfPredictor) and lst_group[k].data
                                    else None
                                )
                                text_2 = v.data[-1].text if isinstance(v, ResultOfPredictor) and v.data else None
                                if text_1 is not None and text_2 is not None and text_1 != text_2:
                                    lst_group[k].data[-1].text += text_2
                        else:
                            items.append(group)

                for idx, item in enumerate(items):
                    if "序号" not in list(tbl_attr.keys()) + list(col_attr.keys()) and "序号" in item:
                        del item["序号"]

                    for attr, value in item.items():
                        if not isinstance(value, ResultOfPredictor) or not value.data:
                            continue
                        if name in ("业务与技术-前五客户", "业务与技术-前五供应商"):
                            if attr in ("客户名称", "供应商名称"):
                                # print(777, [x.text for x in value.data])
                                if len(value.data) != len(cur_col_attr[attr]) and (idx - 1 in range(len(items))):
                                    value.data.insert(0, items[idx - 1][attr].data[0])  # 用上一组的集团名称补充
                                # print(888, [x.text for x in value.data])

                for item in items:
                    if name in ("业务与技术-前五客户", "业务与技术-前五供应商"):
                        for attr, value in item.items():
                            if not isinstance(value, ResultOfPredictor) or not value.data:
                                continue
                            if attr in ("客户名称", "供应商名称"):
                                if len(value.data) == 2:
                                    enterprise, unit = value.data.pop(0), value.data[0]
                                    if re.search(r"小计", unit.text):
                                        unit.text = enterprise.text + unit.text
                                        if hasattr(unit, "chars") and hasattr(enterprise, "chars"):
                                            unit.chars.extend(enterprise.chars)
                    if name == "发行人基本情况-前十自然人股东及其担任职务":
                        for attr, value in item.items():
                            if attr == "是否存在自然人股东在发行人处担任职位的情况":
                                if not (isinstance(value, ResultOfPredictor) and value.data):
                                    continue
                                _val = "是"
                                if any(re.search(r"(无任职|-|^无)", each.text) for each in value.data):
                                    _val = "否"
                                value.value = _val
            else:  # 标注了细则
                item = {}
                # 补充单位
                for attr in UNITS:
                    _val = deepcopy(grp.get(attr))
                    if _val and _val.data:
                        item[attr] = gen_result_struct(
                            item_data=[LabelResult(items=_val.data, text=_val.simple_text())],
                            score=_val.score,
                        )
                for _attr in export_attrs:
                    attr = _extra[_attr] if _attr in _extra else _attr
                    val = deepcopy(grp.get(attr) or grp.get(re.sub(r"原文单位$", "", _attr)))  # 尝试从原文中取单位
                    if not val or not val.data:
                        item[_attr] = None
                        continue
                    _text = val.simple_text(enum=False)
                    if _attr.endswith("原文单位"):
                        _text = get_num_from_chars(_text, AMOUNT_UNIT_PATTERN, clear=r",|人民币")
                        val.data[0]["boxes"][0]["text"] = _text
                    item[_attr] = gen_result_struct(
                        item_data=[LabelResult(items=val.data, text=_text)], value=val.value, score=val.score
                    )
                    page_noes += [box["page"] for box in val.data[0]["boxes"]]
                items.append(item)
            res.extend(items)
        # 补充单位
        for idx, group in enumerate(res):
            if idx != 0:
                for attr in last_group:
                    if attr == "page_no":
                        continue
                    # if attr.startswith("<") or attr.startswith(">") or attr.startswith("（"):
                    #     continue
                    if re.search(r"单位", attr) and not group.get(attr):
                        group[attr] = last_group[attr]
            last_group = group

        # 去重
        ret = OrderedDict()
        for item in res:
            _hash = hashlib.md5(
                json.dumps({k: [x.text for x in v.data] for k, v in item.items() if v and v.data}).encode()
            ).hexdigest()
            ret.setdefault(_hash, item)
        ret = [dic for _, dic in ret.items()]
        if page_noes:
            ret.insert(0, {"page_no": str(sorted(page_noes)[0] if page_noes else "")})
        return ret

    def equity_situation(self, item_dict, **kwargs):
        """
        发行人基本情况-股本情况
        """
        col_attr = {
            "股东名称": None,
            "股东持股数量": None,
            "股东持股数量原文": None,
            "股东持股比例": None,
            "股东持股比例原文": None,
        }
        tbl_attr = {"<数量单位>": None, "<百分比单位>": None, "股东持股数量原文单位": None, "年度": None}
        pass_rows = ["序号|(股东)?名称|持股(数量?|比例)|发行前", "本次(公开)?发行.*", "(社会公众股|流通股)"]
        _extra = {
            "股东持股数量原文": "股东持股数量",
            "股东持股数量原文单位": "<数量单位>",
            "股东持股比例原文": "股东持股比例",
        }
        res = partial(self.row_group, name="发行人基本情况-股本情况")(
            item_dict, col_attr, tbl_attr, pass_rows, _extra=_extra
        )
        return res

    def shareholders(self, item_dict, **kwargs):
        """
        发行人基本情况-前十股东
        """
        col_attr = {
            "股东序号": None,
            "股东名称": None,
            "股东持股数量": None,
            "股东持股数量原文": None,
            "股东持股比例": None,
            "股东持股比例原文": None,
        }
        tbl_attr = {"<数量单位>": None, "<百分比单位>": None, "股东持股数量原文单位": None, "年度": None}
        pass_rows = ["序号|(股东)?名称"]
        _extra = {
            "股东持股数量原文": "股东持股数量",
            "股东持股数量原文单位": "<数量单位>",
            "股东持股比例原文": "股东持股比例",
        }
        res = partial(self.row_group, name="发行人基本情况-前十股东")(
            item_dict, col_attr, tbl_attr, pass_rows, _extra=_extra
        )

        # todo: 筛选前十个
        # result = []
        # for item in res:
        #     flag = True
        #     for attr, each in item.items():
        #         if attr == '股东序号' and isinstance(each, ResultOfPredictor):
        #             try:
        #                 if any(int(x.text) > 10 for x in each.data):
        #                     flag = False
        #             except ValueError:
        #                 pass
        #     if flag:
        #         result.append(item)
        return res

    def natural_shareholders(self, item_dict, **kwargs):
        """
        发行人基本情况-前十自然人股东及其担任职务
        """
        col_attr = {
            "股东名称": None,
            "股东持股数量": None,
            "股东持股数量原文": None,
            "股东持股数量原文单位": None,
            "股东持股比例": None,
            "股东持股比例原文": None,
            "在发行人处担任的职位": None,
            "自然人股东及在发行人处担任职位的情况原文": None,
            "是否存在自然人股东及在发行人处担任职位的情况": None,
        }
        tbl_attr = {
            "<数量单位>": None,
            "<百分比单位>": None,
            "股东持股数量原文单位": None,
            "是否存在自然人股东及在发行人处担任职位的情况": None,
            "年度": None,
        }
        pass_rows = ["^([序编]号|(股东)?(名称|姓名)|任职情况)$", "持股(数量|比例)"]
        _extra = {
            "股东持股数量原文": "股东持股数量",
            "股东持股数量原文单位": "<数量单位>",
            "股东持股比例原文": "股东持股比例",
            "自然人股东及在发行人处担任职位的情况原文": "在发行人处担任的职位",
            "是否存在自然人股东在发行人处担任职位的情况": "是否存在自然人股东及在发行人处担任职位的情况",
        }
        res = partial(self.row_group, name="发行人基本情况-前十自然人股东及其担任职务")(
            item_dict, col_attr, tbl_attr, pass_rows, _extra=_extra
        )
        return res

    def payment_situation(self, item_dict, **kwargs):
        """
        发行人基本情况-薪酬情况
        """
        col_attr = {"姓名": None, "职务": None, "薪酬金额": None, "薪酬金额原文": None, "薪酬金额币种": None}
        tbl_attr = {"<金额单位>": None, "年度": None, "薪酬金额原文单位": None}
        pass_rows = ["序号|姓名|项目"]
        _extra = {"薪酬金额原文单位": "<金额单位>", "薪酬金额原文": "薪酬金额", "薪酬金额币种": "币种"}
        res = partial(self.row_group, name="发行人基本情况-薪酬情况")(
            item_dict, col_attr, tbl_attr, pass_rows, _extra=_extra
        )
        return res

    def patent(self, item_dict, **kwargs):
        """
        业务与技术-专利
        """
        col_attr = {
            "专利名称": None,
            "专利号": None,
            "专利类型": None,
            "权利人": None,
            "授权公告日": None,
            "专利期限": None,
            "专利授权国家": None,
            "申请日": None,
        }
        tbl_attr = {"专利授权国家": None, "专利类型": None, "权利人": None, "专利期限": None, "年度": None}
        mid_attr = [("权利人", [".*"])]
        pass_rows = ["^([序编]号|专利权人|权利人|(专利)?名称|(申请|专利|授权)[号日])$"]
        res = partial(self.row_group, name="业务与技术-专利")(
            item_dict, col_attr, tbl_attr, pass_rows, mid_attr=mid_attr
        )

        return res

    def software_copyright(self, item_dict, **kwargs):
        """
        业务与技术-软件著作权
        """
        col_attr = {
            "软件名称": None,
            "登记号": None,
            "著作权人": None,
            "取得方式": None,
            "首次发表日期": None,
            "首次发表日期备注": None,
            "登记日期": None,
            "证书号": None,
        }
        tbl_attr = {"著作权人": None, "取得方式": None, "年度": None}
        pass_rows = ["序号"]
        _extra = {
            # '首次发表日期备注': '首次发表日期',
        }
        res = partial(self.row_group, name="业务与技术-软件著作权")(
            item_dict, col_attr, tbl_attr, pass_rows, _extra=_extra
        )
        return res

    def awards(self, item_dict, **kwargs):
        """
        业务与技术-获奖情况
        """
        col_attr = {
            "奖项名称": None,
            "获奖时间": None,
            "获奖时间备注": None,
            "颁发机构": None,
            "获奖项目名称": None,
            "奖励等级": None,
            "获奖人": None,
        }
        tbl_attr = {"获奖人": None, "年度": None}
        pass_rows = [
            "序号",
            "^(所获奖项|项目名称|证书编号|荣誉(称号|类别|名称|登记)|奖项名称|奖项|时间|评选单位)$",
            "^([获颁发]奖|颁发|授予)?(机构|时间|单位|年份)$",
        ]
        _extra = {
            # '获奖时间备注': '获奖时间',
        }
        res = partial(self.row_group, name="业务与技术-获奖情况")(
            item_dict, col_attr, tbl_attr, pass_rows, _extra=_extra
        )
        return res

    def projects(self, item_dict, **kwargs):
        """
        业务与技术-在研项目
        """
        col_attr = {
            "项目名称/编码": None,
            "项目进展": None,
            "投入研发人数/人员": None,
            "经费投入": None,
            "经费投入原文": None,
            "项目介绍": None,
            "目标": None,
        }
        tbl_attr = {"<金额单位>": None, "经费投入原文单位": None, "<百分比单位>": None, "年度": None}
        pass_rows = ["^((项目|技术)?名称|(研发|在研)?(项目|技术)名称|产品)$", "^(编号|序号|编码|项目)$", "进展(情况)?$"]
        _extra = {"经费投入币种": "币种", "经费投入原文": "经费投入", "经费投入原文单位": "<金额单位>"}
        res = partial(self.row_group, name="业务与技术-在研项目")(
            item_dict, col_attr, tbl_attr, pass_rows, _extra=_extra
        )
        return res

    def sci_projects(self, item_dict, **kwargs):
        """
        业务与技术-科研项目
        """
        col_attr = {
            "项目名称": None,
            "项目类型": None,
            "角色": None,
            "进度": None,
            "项目级别": None,
            "项目内容": None,
            "共同参与者": None,
            "发起组织": None,
            "拨款数额": None,
            "拨款数额原文": None,
            "拨款数额原文单位": None,
            "拨款数额币种": None,
            "自筹数额": None,
            "自筹数额原文": None,
            "自筹数额原文单位": None,
            "自筹数额币种": None,
            "项目预算": None,
            "项目预算原文": None,
            "项目预算原文单位": None,
            "项目时间": None,
        }
        tbl_attr = {"<金额单位>": None, "<时间单位>": None, "年度": None}
        pass_rows = ["^((项目|技术)?名称|(研发|在研)?(项目|技术)名称|产品)$", "^(编号|序号|编码|项目)$", "进展(情况)?$"]
        _extra = {
            "拨款数额原文": "拨款数额",
            "拨款数额原文单位": "<金额单位>",
            "拨款数额币种": "币种",
            "自筹数额原文": "自筹数额",
            "自筹数额原文单位": "<金额单位>",
            "自筹数额币种": "币种",
            "项目预算原文": "项目预算",
            "项目预算原文单位": "<金额单位>",
            "项目预算币种": "币种",
        }
        res = partial(self.row_group, name="业务与技术-科研项目")(
            item_dict, col_attr, tbl_attr, pass_rows, _extra=_extra
        )
        return res

    def standards(self, item_dict, **kwargs):
        """
        业务与技术-发行人参与制定的标准
        """
        col_attr = {"标准名称": None, "标准号": None, "担任角色": None, "标准类别": None, "进展状态": None}
        tbl_attr = {"年度": None}
        pass_rows = ["^(标准(名称|号)|进展状态格?)$"]
        _extra = {"进展状态": "进展状态格"}
        res = partial(self.row_group, name="业务与技术-发行人参与制定的标准")(
            item_dict, col_attr, tbl_attr, pass_rows, _extra=_extra
        )
        return res

    def customers(self, item_dict, **kwargs):
        """
        业务与技术-前五客户
        """
        col_attr = {
            "年度": None,
            "序号": None,
            "客户名称": None,
            "销售金额": None,
            "销售金额原文": None,
            "销售金额原文单位": None,
            "销售金额币种": None,
            "占营业收入的比例": None,
            "占营业收入的比例原文": None,
            "销售产品/类型": None,
        }
        tbl_attr = {
            "<金额单位>": None,
            "销售金额原文单位": None,
            "<百分比单位>": None,
            "年度": None,
            "销售产品/类型": None,
        }
        pass_rows = ["序号", "^(客户)?名称$", "^占.*的?比例$", "营业总收入"]
        _extra = {
            "销售金额原文": "销售金额",
            "占营业收入的比例原文": "占营业收入的比例",
            "销售金额原文单位": "<金额单位>",
            "销售金额币种": "币种",
        }
        res = partial(self.row_group, name="业务与技术-前五客户")(
            item_dict, col_attr, tbl_attr, pass_rows, time_key="年度", _extra=_extra
        )
        return res

    def suppliers(self, item_dict, **kwargs):
        """
        业务与技术-前五供应商
        """
        col_attr = {
            "年度": None,
            "序号": None,
            "供应商名称": None,
            "采购金额": None,
            "采购金额原文": None,
            "采购金额原文单位": None,
            "采购金额币种": None,
            "采购金额占营业成本的比例": None,
            "采购金额占营业成本的比例原文": None,
            "采购产品/类型": None,
            "采购金额占当期采购总额比例": None,
            "采购金额占当期采购总额比例原文": None,
        }
        tbl_attr = {
            "<金额单位>": None,
            "采购金额原文单位": None,
            "<百分比单位>": None,
            "年度": None,
            "采购产品/类型": None,
        }
        pass_rows = ["序号|项目", "^(供应商|客户)?名称$"]
        _extra = {
            "采购金额原文": "采购金额",
            "采购金额占营业成本的比例原文": "采购金额占营业成本的比例",
            "采购金额占当期采购总额比例原文": "采购金额占当期采购总额比例",
            "采购金额原文单位": "<金额单位>",
            "采购金额币种": "币种",
        }
        res = partial(self.row_group, name="业务与技术-前五供应商")(
            item_dict, col_attr, tbl_attr, pass_rows, time_key="年度", _extra=_extra
        )
        return res

    def research_achievements(self, item_dict, **kwargs):
        """
        业务与技术-科研成果
        """
        col_attr = {"项目名称": None, "项目类型": None, "角色": None}
        tbl_attr = {"年度": None}
        pass_rows = ["序号|(专项|项目)名称"]
        res = partial(self.row_group, name="业务与技术-科研成果")(
            item_dict, col_attr, tbl_attr, pass_rows, grp_key=["项目名称"]
        )
        return res

    def core_tech(self, item_dict, **kwargs):
        """
        业务与技术-主要核心技术
        """
        col_attr = {"技术名称": None, "技术类型": None, "技术来源": None, "特点/特征说明": None, "技术用途": None}
        tbl_attr = {"技术来源": None, "技术类型": None, "年度": None}
        pass_rows = ["序号", "业务板块|技术(名称|来源|简介)|核心基础技术|表现形式"]
        res = partial(self.row_group, name="业务与技术-主要核心技术")(
            item_dict, col_attr, tbl_attr, pass_rows, grp_key=["技术名称"]
        )
        return res

    def professional_qual(self, item_dict, **kwargs):
        """
        业务与技术-专业资质情况
        """
        col_attr = {
            "资质名称": None,
            "资质类型": None,
            "持有人": None,
            "发证时间": None,
            "有效期": None,
            "颁发机构": None,
            "证书编号": None,
            "批件号": None,
        }
        tbl_attr = {
            "资质名称": None,
            "资质类型": None,
            "持有人": None,
            "发证时间": None,
            "颁发机构": None,
            "批件号": None,
            "年度": None,
        }
        pass_rows = [
            "序号",
            "^((资质|产品|证书)名称|批注文号)$",
            "^((登记|发证|批准|颁发)(单位|日期|机关|时间|机构)|持证(人|单位))$",
            "^(有效期限?至?|生产地址)$",
        ]
        res = partial(self.row_group, name="业务与技术-专业资质情况")(item_dict, col_attr, tbl_attr, pass_rows)
        return res

    def share_payment(self, item_dict, **kwargs):
        """
        财务会计信息-股份支付概况
        补充`股份支付金额`
        """
        res = []
        page_noes = []
        export_attrs = self.schema.schema_dict.get(kwargs.get("col_name"), {}).get("orders", [])  # 需要导出的字段
        _extra = {"股份支付金额币种": "币种"}
        for _, grp in sorted(item_dict.items(), key=lambda item: int(item[0])):
            item = {}
            for _attr in export_attrs:
                attr = _extra[_attr] if _attr in _extra else _attr
                val = grp.get(attr)
                if not val or not val.data:
                    continue
                _text = val.simple_text()
                if attr == "股份支付金额原文" and _text == "-":
                    break
                item[_attr] = gen_result_struct(item_data=[LabelResult(items=val.data, text=_text)], score=val.score)
                page_noes += [box["page"] for box in val.data[0]["boxes"]]
            else:
                res.append(item)

        # 补充单位
        for idx, group in enumerate(res):
            if idx != 0:
                for attr in last_group:
                    if attr == "page_no":
                        continue
                    if re.search(r"单位", attr) and not group.get(attr):
                        group[attr] = last_group[attr]
            last_group = group

        # 补充`股份支付的金额`
        for item in res:
            item.setdefault("股份支付金额", item.get("股份支付金额原文"))
        return res

    def label_detail(self, item_dict, **kwargs):
        """
        处理详细标注的二级字段：
            - schema5新增字段
            - 添加`年度`，默认取三大表处的最近一期
            - 补充单位
        """
        res = []
        page_noes = []
        export_attrs = self.schema.schema_dict.get(kwargs.get("col_name"), {}).get("orders", [])  # 需要导出的字段
        _extra = kwargs.get("_extra", {})  # 5 => 4 字段对应关系
        _particial = kwargs.get("_particial", {})
        for _, grp in sorted(item_dict.items(), key=lambda item: int(item[0])):
            item = {}
            # 补充单位
            for unit in UNITS:
                _val = grp.get(unit)
                if not _val and item_dict.get(0):
                    _val = item_dict[0].get(unit)
                if _val and _val.data:
                    grp[unit] = _val
                    item[unit] = gen_result_struct(
                        item_data=[LabelResult(items=_val.data, text=_val.simple_text())], score=_val.score
                    )
            for _attr in export_attrs:
                attr = _extra[_attr] if _attr in _extra else _attr
                val = deepcopy(grp.get(attr) or grp.get(re.sub(r"原文单位$", "", _attr)))  # 尝试从原文中取单位
                if not val or not val.data:
                    item[_attr] = None
                    continue
                # print('---------', _attr, attr, re.sub(r'原文单位$', '', _attr))
                _text = val.simple_text()
                if _attr in _particial and isinstance(_text, str):  # 截取部分原文的属性（原文单位）
                    _text = get_num_from_chars(_text, _particial[_attr])
                    # val.data[0]['boxes'][0]['text'] = _text
                # print('========', _text)
                if isinstance(_text, str):
                    item[_attr] = gen_result_struct(
                        item_data=[LabelResult(items=val.data, text=_text)], score=val.score
                    )
                else:
                    item[_attr] = gen_result_struct(item_data=[LabelResult(items=val.data)], score=val.score)
                page_noes += [box["page"] for box in val.data[0]["boxes"]]
            res.append(item)

        # 补充原文&单位
        for idx, group in enumerate(res):
            if idx != 0:
                for attr in last_group:
                    if attr == "page_no":
                        continue
                    if not group.get(attr) and last_group.get(attr):
                        if attr in UNITS or any(x in attr for x in ("原文单位",)):
                            group[attr] = deepcopy(last_group[attr])
            last_group = group
        return res

    def sharehold_chart(self, item_dict, **kwargs):
        """
        发行人股权结构图 => base64_str
        """
        res = []
        export_attrs = self.schema.schema_dict.get(kwargs.get("col_name"), {}).get("orders", [])  # 需要导出的字段
        _extra = kwargs.get("_extra", {})  # 5 => 4 字段对应关系
        pdf_path = localstorage.mount(self.file.path())
        for _, grp in sorted(item_dict.items(), key=lambda item: int(item[0])):
            item = {}
            for _attr in export_attrs:
                attr = _extra[_attr] if _attr in _extra else _attr
                val = deepcopy(grp.get(attr))
                if not (val or val.data):
                    item[_attr] = None
                    continue
                for label_res in val.data:
                    for box_info in label_res.get("boxes", []):
                        box = box_info["box"]
                        outline = box_to_outline(box)
                        base64_str = outline_base64_str(pdf_path, box_info["page"], outline, scale=1.0)
                        box["text"] = base64_str
                item[_attr] = gen_result_struct(item_data=[LabelResult(items=val.data)], score=val.score)
            res.append(item)
        return res

    def fix_project_name(self, item_dict, **kwargs):
        """
        根据"<项目补充>"来完善"项目名称"
        """

        res = []
        page_noes = []
        export_attrs = self.schema.schema_dict.get(kwargs.get("col_name"), {}).get("orders", [])  # 需要导出的字段
        _extra = kwargs.get("_extra", {})  # schema4 => schema5 对应的字段
        for _, grp in sorted(item_dict.items(), key=lambda item: int(item[0])):
            item = {}
            # 补充单位
            for unit in UNITS:
                _val = grp.get(unit)
                if not _val:
                    _val = list(item_dict.values())[0].get(unit)
                if _val and _val.data:
                    grp[unit] = _val
                    item[unit] = gen_result_struct(
                        item_data=[LabelResult(items=_val.data, text=_val.simple_text())], score=_val.score
                    )

            supplement = grp.get("<项目补充>")
            for _attr in export_attrs:
                attr = _extra[_attr] if _attr in _extra else _attr
                val = grp.get(attr)
                if not val or not val.data:
                    item[_attr] = None
                    continue
                _text = val.simple_text()
                if attr == kwargs.get("project_name"):
                    if supplement and supplement.data:
                        _sup_text = supplement.simple_text()
                        _sup_text = "".join(_sup_text) if isinstance(_sup_text, list) else _sup_text
                        _text = "_".join([_text, _sup_text]) if _text != _sup_text else _text
                        # val.data[0]['text'] = _text

                if isinstance(_text, str):
                    item[_attr] = gen_result_struct(
                        item_data=[LabelResult(items=val.data, text=_text)], score=val.score
                    )
                else:
                    item[_attr] = gen_result_struct(item_data=[LabelResult(items=val.data)], score=val.score)
                page_noes += [box["page"] for box in val.data[0]["boxes"]]
            res.append(item)

        # 补充单位
        for idx, group in enumerate(res):
            if idx != 0:
                for attr in last_group:
                    if attr == "page_no":
                        continue
                    if re.search(r"单位", attr) and not group.get(attr):
                        group[attr] = last_group[attr]
            last_group = group
        return res

    def _big_table(self, item_dict, **kwargs):
        """解析&格式化大表格"""

        def pack_cell(item):
            """组装单元格数据输出"""
            unit = item.get("单位")
            proj = item.get("项目")
            # 归属于母公司所有者的净利润（万元）-> ['归属于母公司所有者的净利润', '万元']
            proj_list = re.sub(r"[（\(](%|\w?元|次|个|倍|股|次/年|元/股)[）\)]$", r"#\1", proj.text).split("#")
            # 判断项目名尾部是否带有单位
            new_unit = None
            if len(proj_list) == 2:
                proj.text, new_unit = proj_list

            if len(proj_list) == 1:
                if re.search(r"率|比[重例]|利率|占.*比", proj_list[0]):
                    proj.text, new_unit = proj_list[0], "%"
                if re.search(r"倍数$", proj_list[0]):
                    proj.text, new_unit = proj_list[0], "倍"

            if new_unit:
                unit.text = new_unit
            elif not unit.text:
                # 如果既没有标单位, 又没有在项目中匹配到, 默认为元
                unit.text = "元"

            ret = {"单位": unit, "项目": proj}
            item.update(ret)
            return item

        def pack_marked_cells(group):
            """解析细标的表格"""
            item, items = OrderedDict(), []

            try:
                elt, attrs = get_attrs_pos(group)
            except MarkException as e:
                logging.error(e)
                return []

            if elt is None:
                return []

            row_cells, _ = group_cells(elt["cells"])
            for key, value in group.items():
                if key.startswith("<") or key == "币种":
                    if value and value.data:
                        item[key] = LabelResult(items=value.data, text=value.simple_text())
                    else:
                        item[key] = LabelResult(items=[], text="人民币" if key == "币种" else None)

            item["单位"] = item.get("<金额单位>") or LabelResult(items=[], text="元")

            if attrs[0].is_date:
                item[attrs[0].name] = LabelResult(items=group[attrs[0].name].data, text=attrs[0].text)
                attrs.pop(0)

            for row_idx, _ in self._sorted_cells(row_cells).items():
                header_p = re.compile(r"^({})$".format("|".join([i.text for i in attrs])))
                cell = elt["cells"]["{}_0".format(row_idx)]
                if header_p.search(self._clean_txt(cell["text"])):  # 跳过跨页表头
                    continue
                _item = OrderedDict()
                for attr in attrs:
                    cell = elt["cells"]["{}_{}".format(row_idx, attr.pos[1])]
                    _item[attr.name] = CharResult(chars=cell["chars"], text=self._clean_txt(cell["text"]))
                if all(int(row_idx) > int(attr.pos[0]) for attr in attrs):
                    _item.update(deepcopy(item))  # 单位放在金额后面
                    # print('=====', row_idx, {k: v.text for k, v in _item.items()})
                    items.append(_item)
                # 忽略"合计"以后的内容, TODO: 可能会出现多个合计的情况
                if any((re.search(r"^[总合共小]计$", v) for k, v in _item.items() if isinstance(v, str))):
                    break
            return items

        def get_header_pos(elt, text, parent_header=None):
            # 根据标注关键字确定起始行标及列索引
            row_cells, _ = group_cells(elt["cells"])

            idx_s, idx_e = 0, None  # 日期列索引起止
            if parent_header and parent_header.is_date and parent_header.pos:
                for cells in self._sorted_cells(row_cells).values():
                    for cell in self._sorted_cells(cells).values():
                        if self._clean_txt(cell["text"]) == parent_header.text:
                            idx_s, idx_e = cell["left"], cell["right"] + 1
                            break
                    if idx_s:
                        break
                else:
                    raise MarkException("没找到日期列索引, 请检查标注")
            # 限定列中遍历查找指定text的单元格位置
            for row_idx, cells in self._sorted_cells(row_cells).items():
                for col_idx, cell in list(self._sorted_cells(cells).items())[idx_s:idx_e]:
                    # if self._clean_txt(cell['text']) == text:
                    if text in self._clean_txt(
                        cell["text"]
                    ):  # TODO: 此处应对标注未框选完整单元格内容的情况, 可能会有问题
                        return row_idx, col_idx

            raise MarkException("没有匹配到该字段: {}, 请检查标注".format(text))

        def get_col_idx(cells):
            for _idx, _cells in self._sorted_cells(cells).items():
                for cell in self._sorted_cells(_cells).values():
                    if cell["left"] == 0:  # 去掉第一列(也许会跨列)
                        continue
                    if cell["right"] - cell["left"] in (1, 2, 3):
                        return _idx, self._sorted_cells(_cells)

        def get_attrs_pos(group):
            Attr = namedtuple("Attr", ("name", "text", "pos", "is_date"))
            elt, attrs = None, []
            for attr, val in group.items():
                if "表格" in attr:
                    for item in self._get_elements(val.data):
                        if item.get("class") == "TABLE":
                            elt = item
                            break
                    break
            if not elt:
                return elt, attrs

            for attr, val in group.items():
                if not val or not val.data:
                    continue
                if "表格" in attr:
                    continue
                if re.search(r"<|币种", attr):
                    continue
                text = self._clean_txt(val.simple_text())
                if re.search(r"年度", attr):
                    if not date_attr_reg.search(text):
                        logging.warning("可能不是一个有效的日期: %s", text)
                    try:
                        pos = get_header_pos(elt, text)
                    except MarkException as e:
                        # 对应恰好表头和表格主体分离跨页的情况, 从表格主体拿不到表头日期信息
                        logging.warning(e)
                        attrs.insert(0, Attr._make([attr, text, None, True]))
                    else:
                        attrs.insert(0, Attr._make([attr, text, pos, True]))
                elif attr.startswith("项目名称"):
                    try:
                        pos = get_header_pos(elt, text)
                    except MarkException as e:
                        # 对应恰好表头和表格主体分离跨页的情况, 从表格主体拿不到表头项目信息
                        logging.warning(e)
                        attrs.append(Attr._make([attr, text, (0, 0), False]))  # 默认项目信息在第一列
                    else:
                        attrs.append(Attr._make([attr, text, pos, False]))
                else:
                    try:
                        pos = get_header_pos(elt, text, attrs[0])
                    except MarkException as e:
                        # 没有匹配到表头的列不做处理, 一般是某某某占比指标
                        logging.warning(e)
                    else:
                        attrs.append(Attr._make([attr, text, pos, False]))
            return elt, attrs

        def _marked_header(group):
            """判断是否标注了需要提取的表头"""
            counts = 0  # 标注表头计数
            for attr, val in group.items():
                if not val or not val.data:
                    continue
                if re.search(r"年度", attr) and date_attr_reg.search(val.simple_text()):
                    counts += 1
                    continue
                if re.search(r"费用", attr) and val.simple_text():
                    counts += 1
                    continue
                if re.search(r"项目", attr) and val.simple_text():
                    counts += 1

            return counts > 2

        def _marked_tbl(group):
            # 判断标注是否为大表格
            for attr, val in group.items():
                if not re.search(r"表格", attr):
                    continue
                if not val or not val.data:
                    continue
                for each in val.data:
                    for box_info in each.get("boxes"):
                        page = box_info["page"]
                        box = box_info["box"]
                        outline = box_to_outline(box)
                        _type, elt = self.reader.find_element_by_outline(page, outline)
                        if elt is not None and _type == "TABLE":
                            return elt, val.score
            return None, None

        if not item_dict:
            return None
        items = []
        page_noes = []
        # 按index排序
        for _, sub_item in sorted(item_dict.items(), key=lambda item: int(item[0])):
            unit = LabelResult(items=[], text="")
            tbl, tbl_score = _marked_tbl(sub_item)
            if tbl:  # 标注了大表格
                if _marked_header(sub_item):  # 标注了指定的表头
                    items.extend(pack_marked_cells(sub_item))
                    if items:  # 只有提取到内容才插入页码信息
                        page_noes.append(tbl["page"])
                else:
                    extra_info = {}
                    sub_item = {k: v for k, v in sub_item.items() if v and v.data}
                    for key, value in sorted(sub_item.items(), key=lambda x: len(x[1].simple_text())):
                        page_noes += [box["page"] for box in value.data[0]["boxes"]]

                        if key.startswith("<"):
                            extra_info[key] = LabelResult(items=value.data, text=value.simple_text())
                            if key == "<金额单位>":
                                unit = self._get_unit(value.data)
                            continue

                        if "表格" in key:  # >表格< or （表格）
                            elts = self._get_elements(value.data)
                            for elt in elts:
                                if not elt.get("cells"):
                                    continue
                                row_cells, col_cells = group_cells(elt["cells"])
                                # 列索引: 通常是日期
                                idx, col_idx_cells = get_col_idx(row_cells)
                                # 行索引: 通常是项目或公司名
                                row_idx_cells = self._sorted_cells(col_cells["0"])

                                for row, row_cell in row_idx_cells.items():  # 项目, 从上到下
                                    group = deepcopy(extra_info)

                                    # 跳过索引行(表头可能为空)
                                    if int(row) < int(idx) or not self._clean_txt(row_cell["text"]):
                                        continue
                                    # 跳过跨页表头
                                    proj = CharResult(chars=row_cell["chars"], text=self._clean_txt(row_cell["text"]))
                                    if not proj or re.search(
                                        r"^(负债[及和](所有者|股东)权益|资产|[项科]目|[子母]?公司|(公司)?名称|(主要)?(财务)?指标)$",
                                        proj.text,
                                    ):
                                        continue
                                    # # 跳过合并行头
                                    # if row_cell['bottom'] - row_cell['top'] != 1:
                                    #     continue

                                    group.update(
                                        {
                                            "单位": LabelResult(items=value.data, text=kwargs.get("unit"))
                                            if kwargs.get("unit")
                                            else unit,
                                            "项目": proj,
                                        }
                                    )

                                    _group = deepcopy(group)
                                    for col, col_cell in col_idx_cells.items():  # 时间, 从左到右
                                        if col_cell["left"] == 0:  # 跳过左侧项目列(可能有合并)
                                            continue
                                        _group.setdefault(
                                            "年度",
                                            CharResult(chars=col_cell["chars"], text=self._clean_txt(col_cell["text"])),
                                        )

                                        _cell = elt["cells"]["{}_{}".format(row, col)]
                                        # 跳过合并单元格
                                        if (_cell["right"] - _cell["left"] != 1) or (
                                            _cell["bottom"] - _cell["top"] != 1
                                        ):
                                            continue

                                        if int(col) - col_cell["left"] == 0:  # 金额
                                            _group.setdefault(
                                                "金额",
                                                CharResult(chars=_cell["chars"], text=self._clean_txt(_cell["text"])),
                                            )
                                            if col_cell["right"] - col_cell["left"] == 1:
                                                items.append(pack_cell(_group))  # 组装一个记录
                                                _group = deepcopy(group)  # 初始化, 继续下一个时间段

                                        elif int(col) - col_cell["left"] == 1:  # 占比
                                            _group.setdefault(
                                                "占比",
                                                CharResult(chars=_cell["chars"], text=self._clean_txt(_cell["text"])),
                                            )
                                            if col_cell["right"] - col_cell["left"] == 2:
                                                items.append(pack_cell(_group))  # 组装一个记录
                                                _group = deepcopy(group)  # 初始化, 继续下一个时间段

                                        elif int(col) - col_cell["left"] == 2:
                                            # _group.setdefault('增加额', self._clean_txt(_cell['text'], is_num=True))
                                            if col_cell["right"] - col_cell["left"] == 3:
                                                items.append(pack_cell(_group))  # 组装一个记录
                                                _group = deepcopy(group)  # 初始化, 继续下一个时间段

                                        else:
                                            # _group.setdefault('未知', self._clean_txt(_cell['text'], is_num=True))
                                            items.append(pack_cell(_group))  # 组装一个记录
                                            _group = deepcopy(group)  # 初始化, 继续下一个时间段
            else:  # 标注了细则
                item = {}
                for attr, val in sub_item.items():
                    if val and val.data:
                        page_noes += [box["page"] for box in val.data[0]["boxes"]]
                        item[attr] = LabelResult(items=val.data, text=val.simple_text())
                items.append(item)
        # 补充单位/币种
        for idx, group in enumerate(items):
            if idx != 0:
                for attr in last_group:  # noqa: F821
                    if attr == "page_no":
                        continue
                    if re.search(r"单位|币种", attr) and (not group.get(attr) or not group[attr].text):
                        group[attr] = last_group[attr]  # noqa: F821
            last_group = group

        if not items:
            logging.warning("%s 没有提取到内容, 请检查", kwargs.get("col_name"))
            return items

        # 去重
        ret = OrderedDict()
        for item in items:
            _hash = hashlib.md5(json.dumps({k: v.text for k, v in item.items()}).encode()).hexdigest()
            ret.setdefault(_hash, item)

        ret = [dic for _, dic in ret.items()]

        # 细标的答案中没有"项目"字段, 也不需要重排
        if "项目" in ret[0] and kwargs.get("re_group"):
            dic = OrderedDict()
            for item in ret:
                dic.setdefault(item["年度"].text, []).append(item)

            ret = []
            for values in dic.values():
                group = {}
                for value in values:
                    for func in (match_financial_attr, guess_attr):
                        attr = func(value["项目"].text, dst_attrs[kwargs.get("col_name")])
                        if attr:
                            group[attr] = value["金额"]
                            break

                # 填充额外信息: 年度/币种/单位等
                for attr in value:
                    if attr.startswith("<") or attr in ("年度", "币种"):
                        group[attr] = value[attr]
                ret.append(group)

        res = []
        _extra_map = {
            "财务会计信息-研发费用细分情况": {
                "项目研发费用币种": "币种",
                "项目研发费用原文": "项目研发费用",
                "项目研发费用原文单位": "<金额单位>",
                "占研发费用比": "占研发费用比（%）",
                "占研发费用比原文": "占研发费用比（%）",
            },
            "财务会计信息-研发费用率与同行业公司对比": {
                "项目名称": "项目/公司名称",
                "研发费用率": "研发费用率（%）",
                "研发费用率原文": "研发费用率（%）",
            },
        }
        col_name = kwargs.get("col_name", "")
        export_words = self.schema.schema_dict.get(col_name, {}).get("orders", [])  # 需要导出的字段
        _extra = _extra_map.get(col_name, {})  # 5 => 4 字段对应关系

        for dic in ret:
            # 可能拿到非年份信息, 直接置空
            if dic.get("年度") and getattr(dic["年度"], "text", None) and dic["年度"].text[0] not in "1234567890":
                dic["年度"].text = ""
                if hasattr(dic["年度"], "items"):
                    dic["年度"].items = []
                if hasattr(dic["年度"], "chars"):
                    dic["年度"].chars = []
            each = OrderedDict()
            for k, v in dic.items():
                if k.startswith("<"):
                    each.setdefault(k, gen_result_struct(item_data=[v], score=tbl_score))
            for _key in export_words:
                key = _extra[_key] if _key in _extra else _key
                v = dic.get(key)
                each[_key] = gen_result_struct(item_data=[v], score=tbl_score)
                each.setdefault(key, gen_result_struct(item_data=[v], score=tbl_score))
            if not export_words:
                for k, v in dic.items():
                    each.setdefault(k, gen_result_struct(item_data=[v], score=tbl_score))
            res.append(each)

        if page_noes:
            res.insert(0, {"page_no": str(sorted(page_noes)[0]) if page_noes else ""})

        return res

    def related_parties(self, item_dict, **kwargs):
        def fill_pos(ass_type, kws, rows):
            # 根据标注表头信息确定对应提取内容行列坐标
            _ = [text.update({"pos": None}) for item in kws for text in item.texts]
            for row_idx, cells in self._sorted_cells(rows).items():
                for col_idx, cell in self._sorted_cells(cells).items():
                    # if not all([text.get('pos') for item in kws for text in item.texts]):
                    for item in kws:
                        for _item in item.texts:
                            if self._clean_txt(cell["text"]) == _item["text"] and _item["pos"] is None:
                                _item["pos"] = (row_idx, col_idx)
                    for key in ass_type.types:
                        text = self._clean_txt(cell["text"])
                        # 有可能是全等, 也可能会省略开头序号或者结尾尾注之类的情况
                        if text == key or text.endswith(key) or text.startswith(key):
                            ass_type.set_pos(key, (row_idx, col_idx))
            ass_type.sorted_types()

        if not item_dict:
            return None
        items = []
        page_noes = []
        Attr = namedtuple("Attr", ("name", "texts", "pattern"))
        for _, sub_item in item_dict.items():
            sub_item = {k: v for k, v in sub_item.items() if v and v.data}
            page_noes += [
                box["page"] for _, item in sub_item.items() for answer in item.data for box in answer["boxes"]
            ]
            _items = []
            if sub_item.get("（表格）"):  # 粗标大表格, 需要解析表格内容, 并补全表格外"关联类型"
                # 记录可能标在表格内的"关联类型"信息
                ass_type = AssociationType(sub_item.get("关联类型"))
                kws = []
                for _key in ("关联方名称", "关联关系"):
                    texts = sub_item.get(_key).simple_text() if sub_item.get(_key) else ""
                    if texts:  # 关联关系可能会标多项
                        if isinstance(texts, list):
                            texts = [{"text": self._clean_txt(text)} for text in texts]
                        else:
                            texts = [{"text": self._clean_txt(texts)}]
                        kws.append(Attr._make([_key, texts, "|".join([i["text"] for i in texts])]))
                    else:
                        logging.error("属性[%s]没有标注", _key)
                # 锚定词一个都没有标, 跳过
                if not kws:
                    logging.warning("关联方名称, 关联关系都没有标注, 请核查标注数据是否完整")
                    continue

                # 过滤首行表头及跨行表头正则
                header_p = re.compile(r"^({})$".format("|".join([i.pattern for i in kws]) + "|序号|姓名"))
                elts = self._get_elements(sub_item["（表格）"].data)
                for elt in elts:
                    if elt["class"] != "TABLE":
                        continue
                    try:
                        row_cells, col_cells = group_cells(elt.get("cells", {}))
                    except TypeError:
                        logging.warning("can't find element, will skip it")
                        continue
                    # 取列项内容位置, 如果没有就跳过
                    fill_pos(ass_type, kws, row_cells)
                    if not any((text.get("pos") for item in kws for text in item.texts)):
                        continue

                    # TODO: 上面判断不严格, 可能缺失"关联方名称"列内容(极小概率事件)
                    _pos = kws[0].texts[0]["pos"]
                    if not _pos:
                        continue
                    row_idx_cells = self._sorted_cells(col_cells[_pos[1]])  # 关联方名称所在列
                    for row, row_cell in row_idx_cells.items():  # 从上到下
                        # 跳过表头/跨页表头/跨列合并单元格
                        if (
                            int(row) <= int(_pos[0])
                            or header_p.search(self._clean_txt(row_cell["text"]))
                            or row_cell["right"] - row_cell["left"] > 1
                        ):
                            continue
                        item = {}
                        for attr in kws:
                            chars, texts = [], []
                            for _item in attr.texts:
                                # 跳过未匹配到的属性
                                if _item["pos"] is None:
                                    continue
                                cell = elt["cells"]["{}_{}".format(row, _item["pos"][1])]
                                text = self._clean_txt(cell["text"])
                                # 只取有内容的非表头/非合并单元格内容
                                if text and not header_p.search(text) and cell["right"] - cell["left"] == 1:
                                    chars.append(cell["chars"])
                                    # 如果是纯数字或百分数, 则需要把表头加上
                                    texts.append(_item["text"] + text if re.search(r"^\d+\.?\d+%?$", text) else text)
                                else:
                                    # 空格子或表头格子, 向后倒退直到取到最近有内容的单元格为止
                                    _row = int(row)
                                    while _row > 0:
                                        cell = elt["cells"]["{}_{}".format(_row, _item["pos"][1])]
                                        text = self._clean_txt(cell["text"])
                                        # 只取有内容的非表头/非合并单元格内容
                                        if text and not header_p.search(text) and cell["right"] - cell["left"] == 1:
                                            chars.append(cell["chars"])
                                            texts.append(
                                                _item["text"] + text if re.search(r"^\d+\.?\d+%?$", text) else text
                                            )
                                            break
                                        _row -= 1

                            for _chars, text in zip(chars, texts):
                                if isinstance(text, str):
                                    item.setdefault(attr.name, []).append(CharResult(chars=_chars, text=text))
                                else:
                                    item.setdefault(attr.name, []).append(CharResult(chars=_chars))

                        # 补充可能出现在表格内的"关联类型"内容
                        if ass_type.types:
                            _ass_item = ass_type.get_item_by_pos((int(row), None))
                            item.setdefault("关联类型", []).append(
                                LabelResult(items=_ass_item.data, text=_ass_item.text)
                            )

                        # 用标注内容补全(表格中可能拿不到内容)
                        for key in ("关联关系",):
                            text = sub_item.get(key).simple_text() if sub_item.get(key) else ""
                            if text and not item.get(key):
                                if isinstance(text, str):
                                    item[key] = [LabelResult(items=sub_item.get(key).data, text=text)]
                                else:
                                    item[key] = [LabelResult(items=sub_item.get(key).data)]

                        # "关联关系"为空, 跨页表格, 取上一项填充
                        if _items and not item.get("关联关系") and _items[-1].get("关联关系"):
                            item["关联关系"] = _items[-1]["关联关系"]

                        # "关联方名称"格子为空, 应该是跨页表格, 故直接添加到上一项"关联关系"中
                        if _items and not item.get("关联方名称") and item.get("关联关系"):
                            _items[-1]["关联关系"].append(item["关联关系"])
                        else:
                            _items.append(item)

            # 没有标大表格, 采用标注答案
            if not _items:
                _item = {}
                for key in "关联方名称", "关联关系":
                    text = sub_item.get(key).simple_text() if sub_item.get(key) else ""
                    if isinstance(text, str):
                        _item[key] = [LabelResult(items=[] if text is None else sub_item.get(key).data, text=text)]
                    else:
                        _item[key] = [LabelResult(items=[] if text is None else sub_item.get(key).data)]
                _items.append(_item)

            # 补充"关联类型"
            texts = sub_item.get("关联类型").simple_text() if sub_item.get("关联类型") else ""
            if isinstance(texts, str):
                for i in _items:
                    i.setdefault("关联类型", [LabelResult(items=sub_item.get("关联类型").data, text=texts)])

            items.extend(_items)

        # 去重
        ret = OrderedDict()
        for item in items:
            try:
                _hash = hashlib.md5(json.dumps({k: [x.text for x in v] for k, v in item.items()}).encode()).hexdigest()
            except AttributeError as e:
                logging.warning(e)
            else:
                ret.setdefault(_hash, item)

        ret = [dic for _, dic in ret.items()]

        # TODO: score
        items = [{k: gen_result_struct(item_data=v, score=1) for k, v in item.items()} for item in ret]
        # 补充年度
        for each in items:
            each.setdefault("年度", None)
        if page_noes:
            items.insert(0, {"page_no": str(sorted(page_noes)[0]) if page_noes else ""})
        return items

    def third_word_unit(self, item_dict, **kwargs):
        """
        将子公司基本情况的三级字段'子公司最近一年及一期末的资产及利润情况'的每一项都加上单位
        """
        items = []
        page_noes = []
        if not item_dict:
            return None

        base_words = self.schema.schema_dict.get("子公司基本情况", {}).get("orders", [])  # 需要导出的字段
        base_extra = {
            "法定代表人": ("法人代表", None),
            "注册资本原文": ("注册资本", None),
            "注册资本原文单位": ("注册资本", AMOUNT_UNIT_PATTERN),
            "实收资本原文": ("实收资本", None),
            "实收资本原文单位": ("实收资本", AMOUNT_UNIT_PATTERN),
        }

        asset_words = self.schema.schema_dict.get("子公司最近一年及一期末的资产及利润情况", {}).get(
            "orders", []
        )  # 需要导出的字段
        asset_extra = {
            "总资产原文": ("总资产", None),
            "总资产原文单位": ("<金额单位>", AMOUNT_UNIT_PATTERN),
            "总资产币种": ("币种", None),
            "净资产原文": ("净资产", None),
            "净资产原文单位": ("<金额单位>", AMOUNT_UNIT_PATTERN),
            "净资产币种": ("币种", None),
            "净利润原文": ("净利润", None),
            "净利润原文单位": ("<金额单位>", AMOUNT_UNIT_PATTERN),
            "净利润币种": ("币种", None),
        }

        common_unit = None
        for _, sub_item in item_dict.items():
            assets_dict = sub_item.get("子公司最近一年及一期末的资产及利润情况")
            if not assets_dict:
                continue
            # 将公司名补充到子公司资产利润情况中
            if "公司名称" in sub_item:
                for _, ch_item in assets_dict.items():
                    ch_item["公司名称"] = sub_item["公司名称"]
            # 子公司资产利润情况的缺省单位
            if assets_dict.get(0):
                unit = assets_dict.get(0).get("<金额单位>")
                if unit and not common_unit:
                    common_unit = unit

        root = kwargs.get("res", {})
        for _, sub_item in item_dict.items():
            # if _ not in [0, ]:
            #     continue
            # print('------', _, sub_item.keys())
            res = {}
            for _key in base_words:
                if _key == "子公司最近一年及一期末的资产及利润情况":
                    # 三级字段，后面单独处理
                    continue
                res.setdefault(_key, None)
                key, pattern = _key, None
                if _key in base_extra:
                    key, pattern = base_extra[_key]
                _answer_item = deepcopy(sub_item.get(key))
                # print('-----', _key, key)
                if _answer_item and _answer_item.data:
                    _text_l, _ = self._table_and_text(_answer_item, join=False)
                    if len(_text_l) == 1:
                        _text = get_num_from_chars(_text_l[0], pattern)
                        # print('****', _text)
                        res[_key] = gen_result_struct(
                            item_data=[LabelResult(items=_answer_item.data, text=_text)], score=_answer_item.score
                        )
                    else:
                        # print('****', _text_l)
                        res[_key] = gen_result_struct(
                            item_data=[LabelResult(items=_answer_item.data)], score=_answer_item.score
                        )
                    page_noes.append(_answer_item.data[0]["boxes"][0]["page"])

            asset_info = sub_item.get("子公司最近一年及一期末的资产及利润情况")
            assets_res = []
            if asset_info:
                for _, _assets_dict in asset_info.items():
                    if not _assets_dict.get("公司名称"):
                        _assets_dict["公司名称"] = res.get("公司名称")
                    if not _assets_dict.get("<金额单位>"):
                        _assets_dict["<金额单位>"] = common_unit
                    assets_grp = OrderedDict()
                    for _assets_key in asset_words:
                        assets_grp.setdefault(_assets_key, None)
                        assets_key, pattern = _assets_key, None
                        if _assets_key in asset_extra:
                            assets_key, pattern = asset_extra[_assets_key]
                        _assets_value = deepcopy(
                            _assets_dict.get(assets_key) or _assets_dict.get(re.sub(r"原文单位$", "", _assets_key))
                        )  # 尝试从原文中取单位
                        # print(_assets_key, assets_key, re.sub(r'原文单位$', '', _assets_key))
                        if _assets_value and _assets_value.data:
                            _text = _assets_value.simple_text()
                            if isinstance(_text, str):
                                _text = get_num_from_chars(_text, pattern)
                                assets_grp[_assets_key] = gen_result_struct(
                                    item_data=[LabelResult(items=_assets_value.data, text=_text)], score=1
                                )
                            else:
                                assets_grp[_assets_key] = gen_result_struct(
                                    item_data=[LabelResult(items=_assets_value.data)], score=1
                                )
                            page_noes.append(_assets_value.data[0]["boxes"][0]["page"])
                    assets_res.append(assets_grp)
            root.setdefault("发行人基本情况-子公司最近一年及一期末的资产及利润情况", []).extend(assets_res)
            items.append(res)
        if page_noes:
            items.insert(0, {"page_no": str(sorted(page_noes)[0]) if page_noes else ""})
        root.setdefault("发行人基本情况-子公司基本情况", []).extend(items)
        return None

    def table2md(self, cells):
        """
        merge info format < MERGE 2, 4, 5, 5 >

        """

        class Cell:
            def __init__(self, text, left, right, top, bottom):
                self.text = text
                self.left = left
                self.right = right
                self.top = top
                self.bottom = bottom

        def sort_table(_index):
            _row, _col = _index.split("_")
            return int(_row), int(_col)

        def find_merge_cell(special_cell):
            merge_format = "<MERGE {top}, {bottom}, {left}, {right}>"
            if special_cell.right - special_cell.left > 1 or special_cell.bottom - special_cell.top > 1:
                merge_info.add(
                    merge_format.format(
                        top=special_cell.top + 1,
                        bottom=special_cell.bottom,
                        left=special_cell.left + 1,
                        right=special_cell.right,
                    )
                )

        def sort_merge_info(_merge_info):
            top, bottom, left, right = _merge_info.split(",")
            top = top.split()[-1]
            bottom = bottom.split()[-1]
            left = left.split()[-1]
            right = right[1:-1]
            return int(top), int(bottom), int(left), int(right)

        res = "|"
        merge_info = set()
        cell_dict = defaultdict(list)
        for index, cell in sorted(cells.items(), key=lambda item: sort_table(item[0])):
            row, col = index.split("_")
            cell_dict[row].append(Cell(cell["text"], cell["left"], cell["right"], cell["top"], cell["bottom"]))

        # 生成表头
        header_cells = cell_dict["0"]
        # header_text = header_cells[0].text
        for header_cell in header_cells:
            res += self._clean_txt(header_cell.text)
            res += "|"
            find_merge_cell(header_cell)
        res += "\n"

        # 生成| ----- | ----- | ----- | ----- |
        res += "|"
        for _ in header_cells:
            res += " ----- |"
        res += "\n"

        # 生成表格体
        for row, _cells in sorted(cell_dict.items(), key=lambda item: int(item[0])):
            # if  not _cells[0].text or _cells[0].text == header_text:
            #     continue
            if row == "0":
                continue
            res += "|"
            for _cell in _cells:
                res += self._clean_txt(_cell.text)
                res += "|"
                find_merge_cell(_cell)
            res += "\n"
        # merge_info = sorted(merge_info, key=lambda x: sort_merge_info(x))
        merge_info = sorted(merge_info, key=sort_merge_info)
        # 生成合并单元格信息
        for _merge in merge_info:
            res += _merge
            res += "\n"
        return res

    def simple_table(self, item_dict, **kwargs):
        """
        处理有左右两列的表格：
        扉页-发行概况
        概览-发行概况（二）
        本次发行概况-发行概况（三）
        发行人基本情况-基本情况
        概览-简要基本情况
        概览-中介机构列表
        # todo 转换时间和提取数值
        """

        def is_label_table(_item_dict):
            is_label_table_flag = True
            for _, _sub_item in _item_dict.items():
                for _key, _val in _sub_item.items():
                    if "表格" in _key and _val is None:
                        is_label_table_flag = False
                        break
            return is_label_table_flag

        def process_four_col(third_cell, four_cell, first_cell, _patterns, score):
            first_key = self._clean_txt(first_cell["text"])
            third_key = self._clean_txt(third_cell["text"])
            four_value = self._clean_txt(four_cell["text"])
            # print('333 %s %s %s' % (first_key, third_key, four_value))
            if re.compile(r"占(公司)?发行后总(股本的?比例)?").search(third_key):
                first_key_pattern = {
                    "发行股数": re.compile(r"发行股数|发行股份数量|发行基础股票数量"),
                    "发行新股数量": re.compile(r"(发行新股|新股发行)的?(数量|股数)|发行新基础股票数"),
                    "股东公开发售股份数量": re.compile("股东公开发售的?(基础)?股[份票]?数量?"),
                }
                for _first_key, _first_pattern in first_key_pattern.items():
                    if _first_pattern.search(first_key):
                        first_key = _first_key
                        break
                origin_key = first_key + "占发行后总股本比例原文"
                if origin_key in export_words:
                    # print('***', origin_key, four_value)
                    res[origin_key] = gen_result_struct(
                        item_data=[CharResult(chars=four_cell["chars"], text=four_value)], score=score
                    )
                for key_suffix in ["占发行后总股本比例（不含超额配售）", "占发行后总股本比例", "占发行后总股本的比例"]:
                    _key = first_key + key_suffix
                    if _key not in export_words:
                        continue
                    for _reg in extract_regs.get(_key, []):
                        _val = get_num_from_chars(four_value, _reg, clear=r",|人民币")
                        if _val:
                            break
                    else:
                        _val = four_value
                    if not res.get(_key):
                        # print('***', _key, _val)
                        res.setdefault(
                            _key,
                            gen_result_struct(item_data=[CharResult(chars=four_cell["chars"], text=_val)], score=score),
                        )
            elif re.compile(r"发行[前后]每股收益").search(third_key):
                _key = first_key[:3] + "每股收益"
                for _reg in extract_regs.get(_key, []):
                    _value = get_num_from_chars(four_value, _reg, clear=r",|人民币")
                    if _key not in res and _value:
                        res[_key] = gen_result_struct(
                            item_data=[CharResult(chars=four_cell["chars"], text=_value)], score=score
                        )
                for _suffix, _reg in [("每股收益原文", None), ("每股收益原文单位", AMOUNT_UNIT_PATTERN)]:
                    _key = first_key[:3] + _suffix
                    if _key not in export_words:
                        continue
                    _val = get_num_from_chars(four_value, _reg, clear=r",|人民币")
                    if _key not in res and _val:
                        res.setdefault(
                            _key,
                            gen_result_struct(item_data=[CharResult(chars=four_cell["chars"], text=_val)], score=score),
                        )
            else:
                for export_word in export_words:
                    _pattern = _patterns.get(export_word, Regular(re.compile(export_word)))
                    if _pattern.reg.search(third_key):
                        if _pattern.extra and _pattern.extra.search(third_key):
                            continue
                        reg_key = third_key if "原文单位" not in third_key else "原文单位"
                        regs = extract_regs.get(reg_key, [])
                        _text = "" if regs else four_value
                        if regs:
                            for extract_pattern in regs:
                                matched = extract_pattern.search(four_value)
                                if matched:
                                    _text = matched.groupdict().get("target", "")
                                    break
                        if _text:
                            char_res = CharResult(chars=four_cell["chars"], text=_text)
                            if not res.get(export_word):
                                # print('*****', export_word, _text)
                                res[export_word] = gen_result_struct(item_data=[char_res], score=score)
                        break

        def get_kv_pair_by_row(_row_cells, col_start=0):
            if len(_row_cells) == 4 and all(
                (
                    _row_cells[0].get("dummy", False),
                    _row_cells[2].get("dummy", False),
                    not _row_cells[1].get("dummy", False),
                    _row_cells[3].get("dummy", False),
                )
            ):
                _avliable_cells = _row_cells
            elif len(_row_cells) == 2 and any((_row_cells[0].get("dummy", False), _row_cells[1].get("dummy", False))):
                _avliable_cells = _row_cells
            elif len(_row_cells) == 3:
                if all(
                    (
                        _row_cells[0].get("dummy", False),
                        not _row_cells[1].get("dummy", False),
                        not _row_cells[2].get("dummy", False),
                    )
                ):
                    _avliable_cells = _row_cells
                    _avliable_cells.insert(2, _row_cells[0])
                else:
                    _avliable_cells = _row_cells
                    _avliable_cells = _avliable_cells[1:]

            elif len(_row_cells) == 5 and all(
                (
                    _row_cells[0].get("dummy", False),
                    not _row_cells[1].get("dummy", False),
                    _row_cells[2].get("dummy", False),
                    not _row_cells[3].get("dummy", False),
                    _row_cells[4].get("dummy", False),
                )
            ):
                _avliable_cells = _row_cells
                _avliable_cells.remove(_row_cells[2])
                _avliable_cells.insert(2, _row_cells[0])
            else:
                _avliable_cells = [c for c in _row_cells[col_start:] if not c.get("dummy")]
            return list(zip(_avliable_cells[0::2], _avliable_cells[1::2]))

        if not item_dict:
            return None
        items = []
        col_name = kwargs["col_name"]
        export_words = self.schema.schema_dict.get(col_name, {}).get("orders", [])  # 需要导出的字段
        _extra = kwargs.get("_extra", {})
        # print(col_name, export_words)
        # print('_extra', _extra)
        page_noes = []
        if not is_label_table(item_dict):  # 标注了细则
            res = {export_word: None for export_word in export_words}
            for _, sub_item in sorted(item_dict.items(), key=lambda item: int(item[0])):
                for _key in export_words:
                    key = _extra[_key] if _key in _extra else _key
                    # 尝试从原文中取单位
                    answer_item = deepcopy(sub_item.get(key) or sub_item.get(re.sub(r"原文(单位)?$", "", _key)))
                    if not (answer_item and answer_item.data):
                        continue
                    page_noes += [box["page"] for box in answer_item.data[0]["boxes"]]
                    reg_key = "原文单位" if _key.endswith("原文单位") else key
                    regs = extract_regs.get(reg_key, [])
                    answer_value = answer_item.simple_text()
                    if isinstance(answer_value, str):
                        if regs:
                            for extract_pattern in regs:
                                _value = get_num_from_chars(answer_value, extract_pattern, clear=r",|人民币")
                                # print('~~~~~', extract_pattern, _value)
                                if _value:
                                    answer_value = _value
                                    break
                        answer_item.data[0]["boxes"][0]["text"] = answer_value
                        res[_key] = gen_result_struct(
                            item_data=[LabelResult(items=answer_item.data, text=answer_value)], score=answer_item.score
                        )
                    else:
                        res[_key] = gen_result_struct(
                            item_data=[LabelResult(items=answer_item.data)], score=answer_item.score
                        )
            items.append(res)
            if page_noes:
                items.insert(0, {"page_no": str(sorted(page_noes)[0]) if page_noes else ""})
        else:  # 标注了大表格
            patterns = simple_table_regs.get(col_name, {})
            for _, pattern in patterns.items():
                pattern.flag = True
            for _, sub_item in sorted(item_dict.items(), key=lambda item: int(item[0])):
                res = {}
                sub_item = {k: v for k, v in sub_item.items() if v and v.data}
                for key, item in sorted(sub_item.items(), key=lambda item: len(item[1].data[0]["boxes"][0]["text"])):
                    value = item.data
                    if key in _extra.values():
                        for to_key, from_key in _extra.items():
                            if key == from_key:
                                res[to_key] = gen_result_struct(
                                    item_data=[LabelResult(items=value, text=value[0]["boxes"][0]["text"])],
                                    score=item.score,
                                )
                    if "币种" in key:
                        res[key] = gen_result_struct(
                            item_data=[LabelResult(items=value, text=value[0]["boxes"][0]["text"])], score=item.score
                        )
                    elif "表格" in key:
                        page_noes += [box["page"] for box in value[0]["boxes"]]
                        elts = self._get_elements(value)
                        for elt in elts:
                            if not elt.get("cells"):
                                continue
                            col_start = 0
                            if re.search(r"序号", elt["cells"]["0_0"]["text"]):
                                col_start = 1
                            row_cells, col_cells = group_cells(elt["cells"])

                            for export_word in export_words:
                                # if export_word != '发行股数原文':
                                #     continue
                                pattern = patterns.setdefault(export_word, Regular(re.compile(export_word)))
                                if not pattern.flag:
                                    continue
                                for cells in row_cells.values():
                                    sorted_cells = [
                                        c[1] for c in sorted(cells.items(), key=lambda i: i[0]) if not c[1].get("dummy")
                                    ]
                                    kv_pairs = get_kv_pair_by_row(sorted_cells, col_start=col_start)
                                    if not kv_pairs:
                                        continue
                                    key_cell, value_cell = kv_pairs[0]
                                    if pattern.flag and pattern.reg.search(self._clean_txt(key_cell["text"])):
                                        if pattern.extra and pattern.extra.search(self._clean_txt(key_cell["text"])):
                                            continue
                                        _value = self._clean_txt(value_cell["text"])
                                        if _value and not pattern.multi:
                                            pattern.flag = False
                                        for proportion_key_cell, proportion_value_cell in kv_pairs[1:]:
                                            process_four_col(
                                                proportion_key_cell,
                                                proportion_value_cell,
                                                key_cell,
                                                patterns,
                                                item.score,
                                            )
                                        reg_key = export_word if "原文单位" not in export_word else "原文单位"
                                        # extract_pattern = extract_regs.get(reg_key)
                                        regs = extract_regs.get(reg_key, [])
                                        value_chars = [] if regs else value_cell["chars"]
                                        if regs and _value:
                                            for extract_pattern in regs:
                                                if extract_pattern.search(_value):
                                                    for each in extract_pattern.finditer(_value):
                                                        c_start, c_end = each.start("target"), each.end("target")
                                                        sp_start, sp_end = index_in_space_string(
                                                            value_cell["text"], (c_start, c_end)
                                                        )
                                                        value_chars = value_cell["chars"][sp_start:sp_end]
                                                        break
                                                if value_chars:
                                                    break
                                            # else:
                                            #     value_chars = value_cell['chars']
                                        if value_chars:
                                            # print('*******', [x['text'] for x in value_chars])
                                            res.setdefault(
                                                export_word,
                                                gen_result_struct(
                                                    item_data=[
                                                        CharResult(
                                                            chars=value_chars,
                                                            text="".join([x.get("text", "") for x in value_chars]),
                                                        )
                                                    ],
                                                    score=item.score,
                                                ),
                                            )
                                            # char_res = CharResult(chars=value_chars, text=''.join(
                                            #     [x.get('text', '') for x in value_chars]))
                                            # if export_word in res:
                                            #     if char_res.text not in [x.text for x in res[export_word].data]:
                                            #         res[export_word].data.append(
                                            #             CharResult(chars=value_chars, text=''.join(
                                            #                 [x.get('text', '') for x in value_chars])))
                                            # else:
                                            #     res[export_word] = gen_result_struct(
                                            #         item_data=[CharResult(chars=value_chars, text=''.join(
                                            #             [x.get('text', '') for x in value_chars]))])
                                        if not pattern.flag:
                                            break

                    else:  # 即标大表格，又标注明细
                        _text, _page_noes = self._table_and_text(AnswerItem(data=value, score=item.score))
                        for val_item in value:
                            val_item["text"] = _text
                        res[key] = gen_result_struct(item_data=[LabelResult(items=value, text=_text)], score=item.score)
                for export_word in export_words:
                    res.setdefault(export_word, None)
                items.append(res)
            if page_noes:
                items.insert(0, {"page_no": str(sorted(page_noes)[0]) if page_noes else ""})
        return items


extract_regs = {
    # 扉页-发行概况
    "发行股数上限": [re.compile(r"(不(多于|超过)|≤)(?P<target>[\d\s,.【】\[\]]+?[千万亿]?)股")],
    "发行股数下限": [re.compile(r"(不(少于|低于)|≥)(?P<target>[\d\s,.【】\[\]]+?[千万亿]?)股")],
    "发行股数占发行后总股本比例（不含超额配售）": [
        re.compile(r"(总股[本数]|股份总数)的(比[例率])?([为是]|不[低少高]于|不超过|≥|≤)?(?P<target>.+?)[%％]"),
        re.compile(r"(?P<target>.+?)[%％]"),
    ],
    "发行股数占发行后总股本比例原文": [
        re.compile(r".*(?P<target>(?<=[,，；。）]).*?(总股[本数]|股份总数)的.+?)(?=[,，；。]|$)")
    ],
    "每股面值": [re.compile(r"(人民币|[美日韩]元)?(?P<target>.+?)元")],
    # 概览-简要基本情况
    "注册资本币种": [CURRENCY_PATTERN],
    "实收资本币种": [CURRENCY_PATTERN],
    "发行股数": [re.compile(r"不(少于|超过|低于)(?P<target>.+?)股")],
    "发行新股数量": [re.compile(r"(不(少于|超过|低于)|≥|≤)?(?P<target>.+?)股")],
    "发行股数/发行股数上限": [re.compile(r"不(少于|超过|低于)(?P<target>[\d,.十百千万亿（）()\[\]【】]+?)股")],
    "发行股数上限/发行股数": [re.compile(r"不(少于|超过|低于)(?P<target>[\d,.十百千万亿（）()\[\]【】]+?)股")],
    "发行股数占发行后总股本比例": [re.compile(r"(?P<target>[\d\\.]+?)[%％]")],
    "发行新股数量占发行后总股本比例": [re.compile(r"(?P<target>[\d\\.]+?)[%％]")],
    "股东公开发售股份数量占发行后总股本比例": [
        re.compile(r"(?P<target>[\d\\.]+?)[%％]"),
        re.compile(r"(?P<target>^[\d\\.]+?$)"),
    ],
    "发行前每股净资产": [re.compile(r"(?P<target>.+?)元(/股)?"), re.compile(r"(?P<target>^【.*?】(/股)?)(.*)$")],
    "发行后每股净资产": [re.compile(r"(?P<target>.+?)元(/股)?"), re.compile(r"(?P<target>【.*?】(/股)?)(.*)$")],
    "每股发行价格": [re.compile(r"(?P<target>.+?)元"), re.compile(r"(?P<target>【.*?】(.(/.)?)?$)")],
    "发行市盈率": [re.compile(r"(?P<target>.+?)[倍元]"), re.compile(r"(?P<target>【.*?】(.(/.)?)?$)")],
    "标明计算基础和口径的市盈率": [re.compile(r"(?P<target>.+?)[倍元]"), re.compile(r"(?P<target>【.*?】(.(/.)?)?$)")],
    "标明计算基础和口径的市净率": [re.compile(r"(?P<target>.+?)[倍元]"), re.compile(r"(?P<target>【.*?】(.(/.)?)?$)")],
    "发行市净率": [re.compile(r"(?P<target>.+?)[倍元]"), re.compile(r"(?P<target>【.*?】(.(/.)?)?$)")],
    "发行前每股收益": [re.compile(r"(?P<target>.+?)[倍元](/股)?"), re.compile(r"(?P<target>【[\d\s,.]*】$)")],
    "发行后每股收益": [re.compile(r"(?P<target>.+?)[倍元](/股)?"), re.compile(r"(?P<target>【[\d\s,.]*】$)")],
    "注册资本": [re.compile(r"(人民币)?(?P<target>.*)元?"), re.compile(r"(?P<target>【.*?】(.(/.)?)?$)")],
    "股份公司成立日期": [re.compile(r"股份公司([成建设]立于|：)(?P<target>.*)"), re.compile(r"(?P<target>.*)")],
    "股东公开发售股份数量": [
        re.compile(r"(?P<target>(不涉及股东公开发售股份)|-)"),
        re.compile(r"(?P<target>【[\d\s,.]*】$)"),
        re.compile(r"(?P<target>.*)"),
    ],
    "拟发行新股股票数量": [
        re.compile(r"不(少于|超过|低于)(?P<target>[\d,.十百千万亿（）()\[\]【】]+?)股"),
        re.compile(r"(?P<target>【.*?】(.(/.)?)?$)"),
    ],
    "原文单位": [re.compile(AMOUNT_UNIT_PATTERN)],
}

simple_table_regs = {
    "扉页-发行概况": {
        "发行股票类型": Regular(r"发行股票类型|股票种类"),
        "发行股数上限": Regular(r"发行(基础)?(股[份票]?)?数|股东公开发售(股[份票]?)?数"),
        "发行股数下限": Regular(r"发行(基础)?(股[份票]?)?数|股东公开发售(股[份票]?)?数"),
        "发行股数占发行后总股本比例（不含超额配售）": Regular(r"发行(基础)?(股[份票]?)?数|股东公开发售(股[份票]?)?数"),
        "发行股数原文": Regular(r"发行(基础)?(股[份票]?)?数|股东公开发售(股[份票]?)?数"),
        "发行股数占发行后总股本比例原文": Regular(r"发行(基础)?(股[份票]?)?数|股东公开发售(股[份票]?)?数"),
        "每股面值": Regular(r"(每股|股票|每份存托凭证)面值"),
        "每股面值原文": Regular(r"(每股|股票|每份存托凭证)面值"),
        "每股面值原文单位": Regular(r"(每股|股票|每份存托凭证)面值"),
        "每股发行价格": Regular(r"发行价"),
        "保荐机构相关子公司参与战略配售情况": Regular(r"保荐.*拟?参与战略配售"),
        "发行人高管、员工拟参与战略配售情况": Regular(r"(发行人)?高管、员工拟?参与战略配售"),
        "预计发行日期": Regular(r"预计发行(日期|时间)"),
        "拟上市的交易所和板块": Regular(r"拟上市的?(证券)?交易所(和板块)?"),
        "发行后总股本": Regular(r"^发行后(总股本|股本总额)"),
        "保荐人": Regular(r"保荐(机构|人)", extra=r"联席|子公司"),
        "联席保荐人": Regular(r"联席保荐人|联合保荐机构"),
        "主承销商": Regular(r"主承销商", extra=r"联席"),
        "联席主承销商": Regular(r"联席主承销商"),
        "招股说明书签署日期": Regular(r"签署日"),
    },
    "概览-发行概况（二）": {
        "股票种类": Regular(r"股票种类|证券种类"),
        "每股面值": Regular(r"(每股|股票|每份存托凭证)面值"),
        "每股面值原文": Regular(r"(每股|股票|每份存托凭证)面值"),
        "每股面值原文单位": Regular(r"(每股|股票|每份存托凭证)面值"),
        "发行股数上限": Regular(r"发行(基础)?(股[份票]?)?数|股东公开发售(股[份票]?)?数"),
        "发行股数下限": Regular(r"发行(基础)?(股[份票]?)?数|股东公开发售(股[份票]?)?数"),
        "发行股数原文": Regular(r"发行(基础)?(股[份票]?)?数|股东公开发售(股[份票]?)?数"),
        "发行股数占发行后总股本比例（不含超额配售）": Regular(r"(发行股数)?占(公司)?发行后总股本的?比例"),
        "发行股数占发行后总股本比例原文": Regular(r"(发行股数)?占(公司)?发行后总股本的?比例"),
        "发行新股数量": Regular(r"(发行新股|新股发行)的?(数量|股数)|发行新基础股票数"),
        "发行新股数量占发行后总股本比例": Regular(r"((发行新股|新股发行)的?(数量|股数))?占(公司)?发行后总股本的?比例"),
        "股东公开发售股份数量": Regular(r"^股东公开发售的?(基础)?股[份票]?数量?"),
        "股东公开发售股份数量占发行后总股本比例": Regular(r"(股东公开发售股份数量)?占发行后总股本的?比例"),
        "发行后总股本": Regular(r"^发行后(总股本|股本总额)|CDR发行后总股本"),
        "每股发行价格": Regular(r"(每股)?发行价格"),
        "每股发行价格原文": Regular(r"(每股)?发行价格"),
        "每股发行价格原文单位": Regular(r"(每股)?发行价格"),
        "发行前每股净资产": Regular(r"发行前每股净资产"),
        "发行前每股净资产原文": Regular(r"发行前每股净资产"),
        "发行前每股净资产原文单位": Regular(r"发行前每股净资产"),
        "发行前每股收益": Regular(r"发行前每股收益"),
        "发行前每股收益原文": Regular(r"发行前每股收益"),
        "发行前每股收益原文单位": Regular(r"发行前每股收益"),
        "发行后每股净资产": Regular(r"发行后每股净资产"),
        "发行后每股净资产原文": Regular(r"发行后每股净资产"),
        "发行后每股净资产原文单位": Regular(r"发行后每股净资产"),
        "发行后每股收益": Regular(r"发行后每股收益"),
        "发行后每股收益原文": Regular(r"发行后每股收益"),
        "发行后每股收益原文单位": Regular(r"发行后每股收益"),
        "发行市盈率": Regular(r"发行市盈率"),
        "发行市盈率原文": Regular(r"发行市盈率"),
        "发行市净率": Regular(r"发行市净率"),
        "发行市净率原文": Regular(r"发行市净率"),
        "发行对象": Regular(r"发行对象"),
        "承销方式": Regular(r"承销方式"),
        "拟公开发售股份股东名称": Regular(r"拟公开发售股份股东名称"),
        "发行费用的分摊原则": Regular(r"发行费用的?分(摊|担)原则"),
        "募集费用总额": Regular(r"募集费用总额"),
        "募集费用净额": Regular(r"募集费用净额"),
        "发行费用概算": Regular(r"发行费用概算", multi=True),
    },
    "本次发行概况-发行概况（三）": {
        # '发行股数/发行股数上限': Regular(r'发行股数|发行新股数量|发行规模'),
        "每股面值": Regular(r"(每股|股票|每份存托凭证)面值"),
        "每股面值原文": Regular(r"(每股|股票|每份存托凭证)面值"),
        "每股面值原文单位": Regular(r"(每股|股票|每份存托凭证)面值"),
        "发行股数上限": Regular(r"发行(基础)?(股[份票]?)?数|股东公开发售(股[份票]?)?数"),
        "发行股数下限": Regular(r"发行(基础)?(股[份票]?)?数|股东公开发售(股[份票]?)?数"),
        "发行股数原文": Regular(r"发行(基础)?(股[份票]?)?数|股东公开发售(股[份票]?)?数"),
        "发行股数占发行后总股本比例（不含超额配售）": Regular(
            r"(发行股数)?占(公司)?发行后总股本的?比例|发行(基础)?(股[份票]?)?数量?"
        ),
        "发行股数占发行后总股本比例原文": Regular(
            r"(发行股数)?占(公司)?发行后总股本的?比例|发行(基础)?(股[份票]?)?数量?"
        ),
        "每股发行价格": Regular(r"发行价格?"),
        "每股发行价格原文": Regular(r"(每股)?发行价格"),
        "每股发行价格原文单位": Regular(r"(每股)?发行价格"),
        "发行股数占发行后总股本比例": Regular(r"占发行后总股本的?比例|公开发行新股数量|发行股数|发行规模"),
        "发行新股数量占发行后总股本比例": Regular(r"发行新股数量.*?占发行后总股本的?比例"),
        "股东公开发售股份数量": Regular(r"股东公开发售的?(基础)?股[份票]?数量?"),
        "预测净利润原文": Regular(r"预测净利润"),
        "预测净利润原文单位": Regular(r"预测净利润"),
        "发行前每股收益": Regular(r"发行前每股收益"),
        "发行前每股收益原文": Regular(r"发行前每股收益"),
        "发行前每股收益原文单位": Regular(r"发行前每股收益"),
        "发行后每股收益": Regular(r"发行后每股收益"),
        "发行后每股收益原文": Regular(r"发行后每股收益"),
        "发行后每股收益原文单位": Regular(r"发行后每股收益"),
        "发行前每股净资产": Regular(r"发行前每股净资产"),
        "发行前每股净资产原文": Regular(r"发行前每股净资产"),
        "发行前每股净资产原文单位": Regular(r"发行前每股净资产"),
        "发行后每股净资产": Regular(r"发行后每股净资产"),
        "发行后每股净资产原文": Regular(r"发行后每股净资产"),
        "发行后每股净资产原文单位": Regular(r"发行后每股净资产"),
        "标明计算基础和口径的市盈率": Regular(r"市盈率"),
        "标明计算基础和口径的市盈率原文": Regular(r"市盈率"),
        "标明计算基础和口径的市净率": Regular(r"市净率"),
        "标明计算基础和口径的市净率原文": Regular(r"市净率"),
        "保荐人相关子公司拟参与战略配售情况": Regular(r"保荐.*子公司拟?参与战略配售"),
        # '发行费用概算': Regular(r'发行费用概算', multi=True),
        "发行对象": Regular(r"发行对象", multi=True),
        "股东公开发售股份数量占发行后总股本的比例": Regular(r"股东公开发售股份数量.*?占发行后总股本的?比例"),
        "发行人高管、员工拟参与战略配售情况": Regular(r"发行人高.*?员工拟参与战略配售情况"),
    },
    "发行人基本情况-基本情况": {
        "注册中文名称": Regular(r"(公司|中文|发行人|注册)名称"),
        "注册英文名称": Regular(r"英文名称"),
        "成立日期/有限公司成立日期": Regular(r"^有限(责任)?公司[成设]立(日期|时间)|成立(日期|时间)", extra=r"股份"),
        "股份公司成立日期": Regular(r"股份(有限)?公司.*(日期|时间)|整体变更设立日期"),
        "电话号码": Regular(r"^(公司)?(联系)?电话"),
        "邮政编码": Regular(r"邮政?编码?"),
        "传真号码": Regular(r"传真"),
        "电子信箱": Regular(r"(电子)?[信邮]箱"),
        "互联网网址": Regular(r"^(公司)?(互联网?)?[网地]址"),
        "负责信息披露和投资者关系的负责人": Regular(
            r"((负责)?信息披露)?([和及]投资者关系的?)?(办公室|部门|投资部)?(负责|联系)人"
        ),
        "负责信息披露和投资者关系的负责人电话号码": Regular(
            r"(((负责|联系)人?|办公室|部门|投资部)及?电话|信息披露.*电话)"
        ),
        "负责信息披露和投资者关系的部门": Regular(
            r"((负责)?信息披露[和及])?投资者关系的?(负责|管理)?部门|信息披露部门"
        ),
        "在其他交易所（申请）挂牌或上市的情况": Regular(r"在其他交易场?所.*的情况"),
        "营业范围": Regular(r"营业范围|经营范围"),
        "注册资本币种": Regular(r"注册资本"),
        "注册资本原文": Regular(r"注册资本"),
        "注册资本原文单位": Regular(r"注册资本"),
        "实收资本币种": Regular(r"实收资本"),
        "实收资本原文": Regular(r"实收资本"),
        "实收资本原文单位": Regular(r"实收资本"),
    },
    "概览-简要基本情况": {
        "注册中文名称": Regular(r"中文名称|发行人名称|公司名称"),
        "注册英文名称": Regular(r"英文名称"),
        "注册资本": Regular(r"注册资本"),
        "注册资本币种": Regular(r"注册资本"),
        "注册资本原文": Regular(r"注册资本"),
        "注册资本原文单位": Regular(r"注册资本"),
        "成立日期/有限公司成立日期": Regular(r"(有限公司)?[成设]立(日期|时间)|整体变更设立日期", extra=r"股份"),
        "股份公司成立日期": Regular(r"股份(有限)?公司.*(日期|时间)"),
        "法定代表人": Regular(r"法定代表人"),
        "注册地址": Regular(r"注册地址|公司住所"),
        "主要生产经营地址": Regular(r"主要生产经营地址?|主要经营场所"),
        "控股股东": Regular(r"控股股东"),
        "实际控制人": Regular(r"实际控制人"),
        "行业分类": Regular(r"行业分类"),
        "在其他交易所（申请）挂牌或上市的情况": Regular(r"在其他交?易?场?所"),
    },
    "概览-中介机构列表": {
        "资产评估机构": Regular(r"评估机构"),
        "资产评估复核机构": Regular(r"评估复核机构"),
        "验资复核机构": Regular(r"验资复核机构"),
        "主承销商": Regular(r"^主承销商|保荐人.+?主承销商", extra=r"律师|会计"),
        "保荐人": Regular(r"^保荐(人|机构)|联合保荐机构", extra=r"律师|会计"),
        "其他承销机构": Regular(r"^其他承销商?机构"),
        "保荐人律师": Regular(r"^保荐(人|机构).*律师"),
        "主承销商律师": Regular(r"主承销商.*律师"),
    },
}


def gen_result_struct(item_data=None, value=None, score=None):
    item_data = item_data if item_data else []
    return ResultOfPredictor(data=item_data, value=value, score=score)
